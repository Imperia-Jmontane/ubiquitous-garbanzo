@model MyApp.Models.Home.HomeIndexViewModel
@using System.Text.Json
@using System.Text.Json.Serialization

@{
    ViewData["Title"] = "Repositories";
    JsonSerializerOptions cloneSerializerOptions = new JsonSerializerOptions
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };
    cloneSerializerOptions.Converters.Add(new JsonStringEnumConverter());
    string initialCloneJson = JsonSerializer.Serialize(Model.CloneProgressItems, cloneSerializerOptions);
}

<section class="mx-auto max-w-6xl space-y-10 py-8">
    <div class="rounded-2xl border border-white/10 bg-gray-900/70 p-8 shadow-inner shadow-black/30">
        <h1 class="text-2xl font-semibold text-white">Repository workspace</h1>
        <p class="mt-2 text-sm text-gray-300">Clone repositories to start building their flowcharts.</p>

        <form asp-action="AddRepository" method="post" class="mt-6 space-y-4" data-clone-form="true">
            @Html.AntiForgeryToken()
            <div>
                <label asp-for="AddRepository.RepositoryUrl" class="block text-sm font-medium text-gray-200"></label>
                <div class="mt-2 flex flex-col gap-2 sm:flex-row">
                    <input asp-for="AddRepository.RepositoryUrl" class="w-full rounded-lg border border-white/10 bg-black/40 px-4 py-2 text-sm text-gray-100 placeholder-gray-500 focus:border-indigo-400 focus:outline-none focus:ring-2 focus:ring-indigo-400/40" placeholder="https://github.com/owner/repository.git" data-clone-input="true" />
                    <button type="submit" class="inline-flex items-center justify-center rounded-lg bg-indigo-500 px-4 py-2 text-sm font-semibold text-white shadow-sm transition hover:bg-indigo-400 focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:ring-offset-2 focus:ring-offset-gray-900" data-clone-submit="true">Clone repository</button>
                </div>
                <span asp-validation-for="AddRepository.RepositoryUrl" class="mt-1 block text-sm text-red-300" data-clone-error="true"></span>
            </div>
            <div class="rounded-lg border border-dashed border-white/10 bg-black/30 p-4 text-xs text-gray-400">
                Provide the HTTPS URL for the repository. Private repositories that your GitHub identity can access are supported.
            </div>
        </form>

        @if (!string.IsNullOrWhiteSpace(Model.Notification))
        {
            <div class="mt-6 rounded-lg border border-emerald-500/40 bg-emerald-500/10 p-4 text-sm text-emerald-200">
                <span class="font-semibold">Repository update:</span> @Model.Notification
            </div>
        }

        <div class="mt-6 space-y-4" data-clone-status-list="true"></div>
        <script type="application/json" id="clone-progress-data">@Html.Raw(initialCloneJson)</script>
    </div>

    <div class="rounded-2xl border border-white/10 bg-gray-900/70 p-8 shadow-inner shadow-black/30">
        <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div>
                <h2 class="text-xl font-semibold text-white">Cloned repositories</h2>
                <p class="text-sm text-gray-300">Select a repository to inspect its available branches.</p>
            </div>
            <span class="text-sm text-gray-400" data-repository-count="true" data-count="@Model.Repositories.Count">@Model.Repositories.Count repositor@(Model.Repositories.Count == 1 ? "y" : "ies") available</span>
        </div>
        <div class="mt-8" data-repository-list="true">
            @await Html.PartialAsync("_RepositoryList", Model.Repositories)
        </div>
    </div>
</section>

<div aria-live="assertive" class="pointer-events-none fixed inset-0 flex items-end px-4 py-6 sm:items-start sm:p-6" data-global-notification-region="true">
    <div class="flex w-full flex-col items-center space-y-4 sm:items-end" data-notification-stack="true"></div>
</div>

@section Scripts {
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const cloneForm = document.querySelector('[data-clone-form="true"]');
            const cloneInput = document.querySelector('[data-clone-input="true"]');
            const cloneSubmit = document.querySelector('[data-clone-submit="true"]');
            const cloneError = document.querySelector('[data-clone-error="true"]');
            const cloneList = document.querySelector('[data-clone-status-list="true"]');
            const repositoryList = document.querySelector('[data-repository-list="true"]');
            const repositoryCountLabel = document.querySelector('[data-repository-count="true"]');
            const initialDataElement = document.getElementById('clone-progress-data');
            const globalNotificationRegion = document.querySelector('[data-global-notification-region="true"]');
            const globalNotificationStack = globalNotificationRegion ? globalNotificationRegion.querySelector('[data-notification-stack="true"]') : null;

            if (!cloneList) {
                return;
            }

            const operations = new Map();
            let reloadTimerId = null;
            let repositoryDeleteDialog = null;
            let repositoryDeleteContext = null;
            let repositoryDeleteEscapeBound = false;
            const repositoryCommandConfigurations = {
                fetch: {
                    endpoint: '/api/repositories/fetch',
                    successTitle: 'Fetch completed',
                    successMessage: function (context) {
                        return 'Fetched latest changes for ' + buildRepositoryName(context) + '.';
                    },
                    errorTitle: 'Fetch failed',
                    defaultError: 'Failed to fetch latest changes.',
                    requiresRemote: true
                },
                pull: {
                    endpoint: '/api/repositories/pull',
                    successTitle: 'Pull completed',
                    successMessage: function (context) {
                        return 'Pulled latest changes into ' + buildRepositoryName(context) + '.';
                    },
                    errorTitle: 'Pull failed',
                    defaultError: 'Failed to pull the latest changes.',
                    requiresRemote: true
                },
                push: {
                    endpoint: '/api/repositories/push',
                    successTitle: 'Push completed',
                    successMessage: function (context) {
                        return 'Pushed local commits from ' + buildRepositoryName(context) + '.';
                    },
                    errorTitle: 'Push failed',
                    defaultError: 'Failed to push local commits.',
                    requiresRemote: true
                }
            };

            function buildRepositoryName(context) {
                if (!context || !context.name) {
                    return 'the repository';
                }

                return '"' + context.name + '"';
            }

            if (repositoryCountLabel && repositoryCountLabel.dataset.count) {
                const initialCount = parseInt(repositoryCountLabel.dataset.count || '0', 10) || 0;
                repositoryCountLabel.textContent = formatRepositoryCount(initialCount);
            }

            const initialStates = parseInitialStates(initialDataElement);

            if (initialStates.length > 0) {
                initialStates.forEach(function (state) {
                    upsertOperation(state);
                });
            }

            refreshFromServer();
            initializeRepositoryActions();

            if (cloneForm && cloneInput && cloneSubmit) {
                cloneForm.addEventListener('submit', function (event) {
                    event.preventDefault();
                    beginCloneFromForm();
                });
            }

            function parseInitialStates(scriptElement) {
                if (!scriptElement || !scriptElement.textContent) {
                    return [];
                }

                try {
                    const parsed = JSON.parse(scriptElement.textContent);
                    return Array.isArray(parsed) ? parsed : [];
                } catch (error) {
                    console.warn('Unable to parse initial clone state payload.', error);
                    return [];
                }
            }

            function beginCloneFromForm() {
                const repositoryUrl = cloneInput ? cloneInput.value.trim() : '';

                if (!repositoryUrl) {
                    showError('Please provide a repository URL.');
                    return;
                }

                showError('');
                setFormDisabled(true);

                const payload = {
                    repositoryUrl: repositoryUrl
                };

                fetch('/api/repositories/clone', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'same-origin',
                    body: JSON.stringify(payload)
                })
                    .then(function (response) {
                        if (!response.ok && response.status !== 202) {
                            return response.json().then(function (data) {
                                const message = data && data.message ? data.message : 'Failed to queue repository clone.';
                                throw new Error(message);
                            }).catch(function (error) {
                                throw new Error(error.message || 'Failed to queue repository clone.');
                            });
                        }

                        return response.json();
                    })
                    .then(function (data) {
                        if (!data) {
                            throw new Error('Unexpected response from the server.');
                        }

                        if (cloneInput) {
                            cloneInput.value = '';
                        }

                        handleQueueResponse(data);
                    })
                    .catch(function (error) {
                        showError(error.message || 'Failed to queue repository clone.');
                    })
                    .finally(function () {
                        setFormDisabled(false);
                    });
            }

            function handleQueueResponse(response) {
                if (!response) {
                    return;
                }

                if (shouldShowInProgressNotification(response)) {
                    showGlobalNotification('Clone already in progress', 'We are already cloning this repository. You can monitor the progress below.', 'info');
                }

                const state = convertApiResponseToState(response);
                upsertOperation(state);
            }

            function shouldShowInProgressNotification(response) {
                if (!response || response.alreadyCloned === true) {
                    return false;
                }

                if (response.enqueued === true) {
                    return false;
                }

                const status = response.status || null;

                if (!status) {
                    return false;
                }

                const normalizedState = typeof status.state === 'string' ? status.state.toLowerCase() : '';
                return normalizedState === 'running' || normalizedState === 'queued';
            }

            function showGlobalNotification(title, message, variant) {
                if (!globalNotificationStack) {
                    return;
                }

                const normalizedVariant = typeof variant === 'string' ? variant.toLowerCase() : 'success';
                let iconMarkup = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" data-slot="icon" aria-hidden="true" class="size-6 text-green-400"><path d="M9 12.75 11.25 15 15 9.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" stroke-linecap="round" stroke-linejoin="round"></path></svg>';

                if (normalizedVariant === 'error') {
                    iconMarkup = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" data-slot="icon" aria-hidden="true" class="size-6 text-red-400"><path d="M9.75 9.75 14.25 14.25m0-4.5-4.5 4.5M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" stroke-linecap="round" stroke-linejoin="round"></path></svg>';
                } else if (normalizedVariant === 'info') {
                    iconMarkup = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" data-slot="icon" aria-hidden="true" class="size-6 text-indigo-400"><path d="M12 9v6m0-8.25h.008v.008H12V6.75Zm9 5.25a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" stroke-linecap="round" stroke-linejoin="round"></path></svg>';
                }

                const panel = document.createElement('div');
                panel.className = 'pointer-events-auto w-full max-w-sm transform rounded-lg bg-white opacity-0 shadow-lg outline-1 outline-black/5 transition duration-300 ease-out translate-y-2 sm:translate-x-2 sm:translate-y-0';
                panel.setAttribute('role', 'alert');

                const panelContent = document.createElement('div');
                panelContent.className = 'p-4';
                panel.append(panelContent);

                const header = document.createElement('div');
                header.className = 'flex items-start';
                panelContent.append(header);

                const iconContainer = document.createElement('div');
                iconContainer.className = 'shrink-0';
                iconContainer.innerHTML = iconMarkup;
                header.append(iconContainer);

                const textContainer = document.createElement('div');
                textContainer.className = 'ml-3 w-0 flex-1 pt-0.5';
                header.append(textContainer);

                const titleElement = document.createElement('p');
                titleElement.className = 'text-sm font-medium text-gray-900';
                titleElement.textContent = title;
                textContainer.append(titleElement);

                if (message && message.length > 0) {
                    const messageElement = document.createElement('p');
                    messageElement.className = 'mt-1 text-sm text-gray-500';
                    messageElement.textContent = message;
                    textContainer.append(messageElement);
                }

                const actionContainer = document.createElement('div');
                actionContainer.className = 'ml-4 flex shrink-0';
                header.append(actionContainer);

                const closeButton = document.createElement('button');
                closeButton.type = 'button';
                closeButton.className = 'inline-flex rounded-md text-gray-400 hover:text-gray-500 focus:outline-2 focus:outline-offset-2 focus:outline-indigo-600';
                closeButton.setAttribute('aria-label', 'Close notification');
                closeButton.innerHTML = '<svg viewBox="0 0 20 20" fill="currentColor" data-slot="icon" aria-hidden="true" class="size-5"><path d="M6.28 5.22a.75.75 0 0 0-1.06 1.06L8.94 10l-3.72 3.72a.75.75 0 1 0 1.06 1.06L10 11.06l3.72 3.72a.75.75 0 1 0 1.06-1.06L11.06 10l3.72-3.72a.75.75 0 0 0-1.06-1.06L10 8.94 6.28 5.22Z"></path></svg>';
                actionContainer.append(closeButton);

                let exitTimerId = null;
                let autoDismissId = 0;

                const dismiss = function () {
                    if (panel.getAttribute('data-dismissed') === 'true') {
                        return;
                    }

                    panel.setAttribute('data-dismissed', 'true');

                    if (autoDismissId !== 0) {
                        window.clearTimeout(autoDismissId);
                        autoDismissId = 0;
                    }

                    if (exitTimerId !== null) {
                        window.clearTimeout(exitTimerId);
                        exitTimerId = null;
                    }

                    panel.classList.remove('opacity-100', 'translate-y-0', 'sm:translate-x-0');
                    panel.classList.add('opacity-0', 'translate-y-2', 'sm:translate-x-2');

                    window.setTimeout(function () {
                        if (panel.parentElement) {
                            panel.parentElement.removeChild(panel);
                        }
                    }, 300);
                };

                autoDismissId = window.setTimeout(dismiss, 6000);

                closeButton.addEventListener('click', dismiss);

                panel.addEventListener('mouseenter', function () {
                    if (autoDismissId !== 0) {
                        window.clearTimeout(autoDismissId);
                        autoDismissId = 0;
                    }

                    if (exitTimerId !== null) {
                        window.clearTimeout(exitTimerId);
                        exitTimerId = null;
                    }
                });

                panel.addEventListener('mouseleave', function () {
                    if (panel.getAttribute('data-dismissed') === 'true') {
                        return;
                    }

                    if (exitTimerId !== null) {
                        window.clearTimeout(exitTimerId);
                    }

                    exitTimerId = window.setTimeout(dismiss, 3000);
                });

                globalNotificationStack.append(panel);

                window.requestAnimationFrame(function () {
                    window.requestAnimationFrame(function () {
                        panel.classList.remove('opacity-0', 'translate-y-2', 'sm:translate-x-2');
                        panel.classList.add('opacity-100', 'translate-y-0', 'sm:translate-x-0');
                    });
                });
            }

            function refreshFromServer() {
                fetch('/api/repositories/clone', { cache: 'no-store', credentials: 'same-origin' })
                    .then(function (response) {
                        if (!response.ok) {
                            throw new Error('Unable to load repository clone status list.');
                        }

                        return response.json();
                    })
                    .then(function (payload) {
                        if (!payload || !Array.isArray(payload)) {
                            purgeInactiveOperations();
                            return;
                        }

                        payload.forEach(function (status) {
                            const viewState = convertStatusToViewState(status);
                            upsertOperation(viewState);
                        });

                        purgeInactiveOperations();
                    })
                    .catch(function (error) {
                        console.warn(error);
                    });
            }

            function upsertOperation(state) {
                if (!state) {
                    return null;
                }

                const normalizedRepository = normalizeRepositoryUrl(state.repositoryUrl);
                const key = determineOperationKey(state, normalizedRepository);

                let operationEntry = operations.get(key);

                if (!operationEntry && normalizedRepository) {
                    const existingKey = findEntryKeyByRepository(normalizedRepository);

                    if (existingKey) {
                        operationEntry = operations.get(existingKey);

                        if (operationEntry) {
                            operations.delete(existingKey);
                        }
                    }
                }

                if (!operationEntry) {
                    operationEntry = createOperationEntry(state);
                    cloneList.append(operationEntry.card);
                }

                operationEntry.key = key;
                operationEntry.operationId = state.operationId;
                operationEntry.repositoryUrl = state.repositoryUrl || '';
                operations.set(key, operationEntry);
                bindClose(operationEntry);
                bindCancel(operationEntry);

                updateOperationEntry(operationEntry, state);

                if (state.isActive && reloadTimerId !== null) {
                    window.clearTimeout(reloadTimerId);
                    reloadTimerId = null;
                }

                if (state.operationId && state.operationId !== '00000000-0000-0000-0000-000000000000' && state.isActive) {
                    schedulePoll(operationEntry, state.operationId);
                } else {
                    stopPolling(operationEntry);
                }

                return operationEntry;
            }

            function purgeInactiveOperations() {
                const keysToRemove = [];

                operations.forEach(function (entry, key) {
                    if (!entry || entry.isActive === true) {
                        return;
                    }

                    keysToRemove.push(key);
                });

                keysToRemove.forEach(function (key) {
                    const entry = operations.get(key);

                    if (!entry) {
                        operations.delete(key);
                        return;
                    }

                    removeOperationEntry(entry);
                });
            }

            function determineOperationKey(state, normalizedRepository) {
                const normalized = normalizedRepository || normalizeRepositoryUrl(state.repositoryUrl);

                if (normalized) {
                    return 'repo:' + normalized;
                }

                if (state.operationId && state.operationId !== '00000000-0000-0000-0000-000000000000') {
                    return 'operation:' + state.operationId.toLowerCase();
                }

                return 'static:' + Math.random().toString(36).substring(2);
            }

            function findEntryKeyByRepository(normalizedRepository) {
                if (!normalizedRepository) {
                    return null;
                }

                for (const [entryKey, entryValue] of operations.entries()) {
                    const entryRepository = normalizeRepositoryUrl(entryValue && entryValue.repositoryUrl ? entryValue.repositoryUrl : '');

                    if (entryRepository && entryRepository === normalizedRepository) {
                        return entryKey;
                    }
                }

                return null;
            }

            function normalizeRepositoryUrl(url) {
                if (!url) {
                    return '';
                }

                const trimmed = url.trim().toLowerCase();

                if (trimmed.endsWith('.git')) {
                    return trimmed.substring(0, trimmed.length - 4);
                }

                return trimmed;
            }

            function createOperationEntry(state) {
                const card = document.createElement('div');
                card.className = 'rounded-lg border border-emerald-500/40 bg-emerald-500/10 p-4 text-sm text-emerald-200';
                card.setAttribute('data-operation-card', 'true');

                const header = document.createElement('div');
                header.className = 'flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between';
                card.append(header);

                const title = document.createElement('div');
                title.className = 'flex-1 text-sm';
                header.append(title);

                const strong = document.createElement('span');
                strong.className = 'font-semibold';
                strong.textContent = 'Repository queued:';
                title.append(strong);
                title.append(' ');

                const messageSpan = document.createElement('span');
                messageSpan.setAttribute('data-notification', 'true');
                title.append(messageSpan);

                const actions = document.createElement('div');
                actions.className = 'flex items-center gap-2';
                header.append(actions);

                const badge = document.createElement('span');
                badge.setAttribute('data-status-badge', 'true');
                actions.append(badge);

                const cancelButton = document.createElement('button');
                cancelButton.type = 'button';
                cancelButton.setAttribute('data-cancel', 'true');
                cancelButton.className = 'hidden inline-flex items-center gap-1 rounded-md border border-yellow-500/50 bg-yellow-500/15 px-3 py-1 text-xs font-semibold text-yellow-200 transition hover:bg-yellow-500/25 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-yellow-500';
                cancelButton.innerHTML = '<svg viewBox=\"0 0 20 20\" fill=\"currentColor\" aria-hidden=\"true\" class=\"size-4\"><path d=\"M6.5 5A1.5 1.5 0 0 0 5 6.5v7A1.5 1.5 0 0 0 6.5 15h7a1.5 1.5 0 0 0 1.5-1.5v-7A1.5 1.5 0 0 0 13.5 5h-7Z\"></path></svg><span>Stop cloning</span>';
                actions.append(cancelButton);

                const closeButton = document.createElement('button');
                closeButton.type = 'button';
                closeButton.setAttribute('data-close', 'true');
                closeButton.className = 'hidden rounded-md border border-white/10 bg-white/5 p-1 text-gray-200 transition hover:bg-white/10 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-500';
                closeButton.innerHTML = '<span class=\"sr-only\">Dismiss notification</span><svg viewBox=\"0 0 20 20\" fill=\"currentColor\" aria-hidden=\"true\" class=\"size-4\"><path fill-rule=\"evenodd\" d=\"M4.293 4.293a1 1 0 0 1 1.414 0L10 8.586l4.293-4.293a1 1 0 1 1 1.414 1.414L11.414 10l4.293 4.293a1 1 0 0 1-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L8.586 10 4.293 5.707a1 1 0 0 1 0-1.414Z\" clip-rule=\"evenodd\"></path></svg>';
                actions.append(closeButton);

                const progressContainer = document.createElement('div');
                progressContainer.className = 'mt-4 space-y-3';
                progressContainer.setAttribute('data-progress-container', 'true');
                card.append(progressContainer);

                const stageLabel = document.createElement('p');
                stageLabel.setAttribute('data-stage-label', 'true');
                stageLabel.className = 'text-sm font-medium text-white';
                progressContainer.append(stageLabel);

                const progressBackground = document.createElement('div');
                progressBackground.className = 'overflow-hidden rounded-full bg-white/10';
                progressContainer.append(progressBackground);

                const progressBar = document.createElement('div');
                progressBar.className = 'h-2 rounded-full bg-indigo-500 transition-all duration-500 ease-out';
                progressBar.setAttribute('data-progress-bar', 'true');
                progressBar.style.width = '1%';
                progressBackground.append(progressBar);

                const progressMeta = document.createElement('div');
                progressMeta.className = 'flex items-center justify-between text-xs font-medium text-gray-400';
                progressContainer.append(progressMeta);

                const progressLabel = document.createElement('span');
                progressLabel.textContent = 'Progress';
                progressMeta.append(progressLabel);

                const progressValue = document.createElement('span');
                progressValue.setAttribute('data-progress-value', 'true');
                progressValue.textContent = '0%';
                progressMeta.append(progressValue);

                const stageGrid = document.createElement('div');
                stageGrid.className = 'mt-3 grid grid-cols-4 text-xs font-medium text-gray-400';
                stageGrid.setAttribute('data-progress-steps', 'true');
                progressContainer.append(stageGrid);

                stageGrid.innerHTML = '' +
                    '<div class="text-indigo-400" data-step="queued">Queued</div>' +
                    '<div class="text-center text-gray-400" data-step="receiving">Downloading</div>' +
                    '<div class="text-center text-gray-400" data-step="resolving">Verifying</div>' +
                    '<div class="text-right text-gray-400" data-step="completed">Ready</div>';

                const messageParagraph = document.createElement('p');
                messageParagraph.className = 'mt-3 text-xs text-gray-400';
                messageParagraph.setAttribute('data-progress-message', 'true');
                progressContainer.append(messageParagraph);

                const summaryContainer = document.createElement('div');
                summaryContainer.className = 'mt-4 rounded-md border border-white/10 bg-black/30 px-3 py-2 text-xs text-gray-200';
                summaryContainer.setAttribute('data-summary', 'true');
                summaryContainer.style.display = 'none';
                card.append(summaryContainer);

                return {
                    card: card,
                    badge: badge,
                    titleLabel: strong,
                    messageSpan: messageSpan,
                    progressContainer: progressContainer,
                    stageLabel: stageLabel,
                    progressBar: progressBar,
                    progressValue: progressValue,
                    messageParagraph: messageParagraph,
                    stepsContainer: stageGrid,
                    summaryContainer: summaryContainer,
                    pollTimerId: null,
                    closeButton: closeButton,
                    cancelButton: cancelButton,
                    isActive: state.isActive,
                    state: state.state,
                    operationId: state.operationId,
                    repositoryUrl: state.repositoryUrl || ''
                };
            }

            function updateOperationEntry(entry, state) {
                const wasActive = entry.isActive === true;
                const normalizedStage = state.stage && state.stage.length > 0 ? state.stage : 'Processing repository...';
                const normalizedMessage = state.message && state.message.length > 0 ? state.message : defaultMessageForState(state.state);
                const boundedPercentage = clampPercentage(state.percentage);
                const displayPercentage = boundedPercentage.toFixed(1) + '%';
                const info = computeBadgeInfo(state.state, state.isActive);

                if (entry.cancelButton) {
                    if (state.isActive && state.operationId && state.operationId !== '00000000-0000-0000-0000-000000000000') {
                        entry.cancelButton.classList.remove('hidden');
                        setCancelButtonState(entry.cancelButton, false);
                    } else {
                        entry.cancelButton.classList.add('hidden');
                        setCancelButtonState(entry.cancelButton, false);
                    }
                }

                entry.card.className = cardClassForState(state.state);
                entry.titleLabel.textContent = headingForState(state.state, state.isActive);
                entry.messageSpan.textContent = notificationTextForState(state);
                entry.badge.textContent = info.badgeText;
                entry.badge.className = info.badgeClass;

                if (state.isActive) {
                    entry.progressContainer.style.display = '';
                    entry.summaryContainer.style.display = 'none';
                    if (entry.closeButton) {
                        entry.closeButton.classList.add('hidden');
                    }
                    entry.stageLabel.textContent = normalizedStage;
                    entry.progressBar.style.width = Math.max(1, Math.min(boundedPercentage, 100)).toFixed(1) + '%';
                    entry.progressBar.classList.remove('bg-indigo-500', 'bg-emerald-500', 'bg-red-500');
                    entry.progressBar.classList.add(info.progressClass);
                    entry.progressValue.textContent = displayPercentage;
                    entry.messageParagraph.textContent = normalizedMessage;
                    updateSteps(entry.stepsContainer, normalizedStage, state.state);
                } else {
                    entry.progressContainer.style.display = 'none';
                    entry.summaryContainer.style.display = '';
                    entry.summaryContainer.textContent = finalMessageForState(state.state, state.message);
                    if (entry.closeButton) {
                        entry.closeButton.classList.remove('hidden');
                    }
                    if (state.state === 'Completed') {
                        scheduleRepositoryRefresh();
                    }
                }

                entry.repositoryUrl = state.repositoryUrl || entry.repositoryUrl || '';
                entry.isActive = state.isActive;
                entry.state = state.state;
                entry.operationId = state.operationId;

                if (wasActive && !entry.isActive) {
                    scheduleRepositoryRefresh();
                }
            }

            function notificationTextForState(state) {
                if (!state) {
                    return 'Repository clone';
                }

                if (!state.isActive) {
                    if (state.message && state.message.length > 0) {
                        return state.message;
                    }

                    if (state.repositoryUrl && state.repositoryUrl.length > 0) {
                        return state.repositoryUrl;
                    }
                }

                if (state.notification && state.notification.length > 0) {
                    return state.notification;
                }

                if (state.repositoryUrl && state.repositoryUrl.length > 0) {
                    return state.repositoryUrl;
                }

                return 'Repository clone';
            }

            function defaultMessageForState(stateName) {
                const normalized = (stateName || '').toLowerCase();

                if (normalized === 'failed') {
                    return 'Repository clone failed. Please verify the URL or credentials.';
                }

                if (normalized === 'completed') {
                    return 'Clone completed successfully. Preparing the repository list...';
                }

                if (normalized === 'canceled') {
                    return 'Clone canceled. Previously downloaded files have been removed.';
                }

                return 'We are cloning your repository. This usually takes less than a minute.';
            }

            function headingForState(stateName, isActive) {
                const normalized = (stateName || '').toLowerCase();

                if (normalized === 'failed') {
                    return 'Repository clone failed:';
                }

                if (normalized === 'completed') {
                    return 'Repository cloned:';
                }

                if (normalized === 'canceled') {
                    return 'Repository clone canceled:';
                }

                if (normalized === 'running' && isActive) {
                    return 'Repository cloning:';
                }

                return 'Repository queued:';
            }

            function cardClassForState(stateName) {
                const normalized = (stateName || '').toLowerCase();

                if (normalized === 'failed') {
                    return 'rounded-lg border border-red-500/40 bg-red-500/10 p-4 text-sm text-red-100';
                }

                if (normalized === 'completed') {
                    return 'rounded-lg border border-emerald-500/40 bg-emerald-500/10 p-4 text-sm text-emerald-200';
                }

                if (normalized === 'canceled') {
                    return 'rounded-lg border border-yellow-500/40 bg-yellow-500/10 p-4 text-sm text-yellow-200';
                }

                return 'rounded-lg border border-indigo-500/40 bg-indigo-500/10 p-4 text-sm text-indigo-100';
            }

            function finalMessageForState(stateName, message) {
                if (message && message.length > 0) {
                    return message;
                }

                const normalized = (stateName || '').toLowerCase();

                if (normalized === 'completed') {
                    return 'Clone completed successfully.';
                }

                if (normalized === 'failed') {
                    return 'Clone failed. Please review the repository URL or credentials.';
                }

                if (normalized === 'canceled') {
                    return 'Clone canceled. Local data was removed.';
                }

                return 'Clone status updated.';
            }

            function schedulePoll(entry, operationId) {
                stopPolling(entry);

                entry.pollTimerId = window.setTimeout(function () {
                    pollOperation(entry, operationId);
                }, 1500);
            }

            function stopPolling(entry) {
                if (entry.pollTimerId !== null) {
                    window.clearTimeout(entry.pollTimerId);
                    entry.pollTimerId = null;
                }
            }

            function pollOperation(entry, operationId) {
                fetch('/api/repositories/clone/' + operationId, { cache: 'no-store', credentials: 'same-origin' })
                    .then(function (response) {
                        if (!response.ok) {
                            throw new Error('Status response not available.');
                        }

                        return response.json();
                    })
                    .then(function (payload) {
                        if (!payload) {
                            return;
                        }

                        const viewState = convertStatusToViewState(payload);
                        upsertOperation(viewState);
                    })
                    .catch(function () {
                        // retry with back-off
                        schedulePoll(entry, operationId);
                    });
            }

            function showError(message) {
                if (cloneError) {
                    cloneError.textContent = message || '';
                }
            }

            function setFormDisabled(disabled) {
                if (!cloneSubmit) {
                    return;
                }

                if (disabled) {
                    cloneSubmit.setAttribute('disabled', 'disabled');
                    cloneSubmit.classList.add('opacity-70');
                } else {
                    cloneSubmit.removeAttribute('disabled');
                    cloneSubmit.classList.remove('opacity-70');
                }
            }

            function updateSteps(container, stageText, stateName) {
                if (!container) {
                    return;
                }

                const normalizedStage = (stageText || '').toLowerCase();
                const normalizedState = (stateName || '').toLowerCase();
                const stepElements = container.querySelectorAll('[data-step]');

                stepElements.forEach(function (element) {
                    const step = element.getAttribute('data-step');

                    if (!step) {
                        return;
                    }

                    let active = false;

                    switch (step) {
                        case 'queued':
                            active = true;
                            break;
                        case 'receiving':
                            active = normalizedStage.includes('receiving') || normalizedStage.includes('transfer');
                            break;
                        case 'resolving':
                            active = normalizedStage.includes('resolving') || normalizedStage.includes('index');
                            break;
                        case 'completed':
                            active = normalizedStage.includes('complete') || normalizedStage.includes('ready') || normalizedState === 'completed';
                            break;
                        default:
                            active = false;
                            break;
                    }

                    element.classList.remove('text-indigo-400', 'text-emerald-400');

                    if (active) {
                        element.classList.remove('text-gray-400');

                        if (step === 'completed' && normalizedState === 'completed') {
                            element.classList.add('text-emerald-400');
                        } else {
                            element.classList.add('text-indigo-400');
                        }
                    } else {
                        element.classList.add('text-gray-400');
                    }
                });
            }

            function convertApiResponseToState(response) {
                const status = response.status || null;
                const operationId = status && status.operationId ? status.operationId : response.operationId || '';
                const percentage = status && typeof status.percentage === 'number'
                    ? status.percentage
                    : (status && status.percentage ? parseFloat(status.percentage) : 0);
                const stage = status && status.stage ? status.stage : '';
                const message = status && status.message ? status.message : '';
                const stateName = status && status.state ? status.state : (response.alreadyCloned ? 'Completed' : 'Queued');
                let notification = response.repositoryUrl || 'Repository clone';

                if (response.notification && response.notification.length > 0 && (response.alreadyCloned === true || response.enqueued === true)) {
                    notification = response.notification;
                }

                return {
                    operationId: operationId,
                    repositoryUrl: response.repositoryUrl || '',
                    notification: notification,
                    percentage: percentage,
                    stage: stage,
                    message: message,
                    state: stateName,
                    isActive: stateName === 'Queued' || stateName === 'Running'
                };
            }

            function convertStatusToViewState(status) {
                const rawPercentage = typeof status.percentage === 'number'
                    ? status.percentage
                    : parseFloat(status.percentage || '0') || 0;
                const stageText = status.stage || '';
                const normalizedStage = stageText.toLowerCase();
                let stateName = status.state || '';

                if (!stateName) {
                    if (rawPercentage >= 100 && (normalizedStage.includes('complete') || normalizedStage.includes('ready'))) {
                        stateName = 'Completed';
                    } else {
                        stateName = 'Queued';
                    }
                }

                let isActive = stateName === 'Queued' || stateName === 'Running';

                if (isActive && rawPercentage >= 100 && (normalizedStage.includes('complete') || normalizedStage.includes('ready'))) {
                    stateName = 'Completed';
                    isActive = false;
                }

                return {
                    operationId: status.operationId || '',
                    repositoryUrl: status.repositoryUrl || '',
                    notification: status.repositoryUrl || 'Repository clone',
                    percentage: rawPercentage,
                    stage: stageText,
                    message: status.message || '',
                    state: stateName,
                    isActive: isActive
                };
            }

            function refreshRepositories() {
                if (!repositoryList) {
                    return;
                }

                fetch('/Home/RepositoryList', {
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    credentials: 'same-origin'
                })
                    .then(function (response) {
                        if (!response.ok) {
                            throw new Error('Unable to refresh repository list.');
                        }

                        return response.text();
                    })
                    .then(function (html) {
                        const parser = new DOMParser();
                        const documentFragment = parser.parseFromString(html, 'text/html');
                        const payload = documentFragment.querySelector('[data-repository-payload]');

                        if (!payload) {
                            return;
                        }

                        repositoryList.innerHTML = payload.innerHTML;
                        initializeRepositoryActions();

                        const countAttribute = payload.getAttribute('data-count');
                        const repositoryCount = parseInt(countAttribute || '0', 10) || 0;

                        if (repositoryCountLabel) {
                            repositoryCountLabel.textContent = formatRepositoryCount(repositoryCount);
                            repositoryCountLabel.dataset.count = repositoryCount.toString();
                        }
                    })
                    .catch(function (error) {
                        console.warn(error);
                    });
            }

            function initializeRepositoryActions() {
                if (!repositoryList) {
                    return;
                }

                const deleteButtons = repositoryList.querySelectorAll('[data-repository-delete="true"]');

                deleteButtons.forEach(function (button) {
                    if (button.dataset.bound === 'true') {
                        return;
                    }

                    button.dataset.bound = 'true';
                    button.addEventListener('click', function () {
                        const context = {
                            name: button.getAttribute('data-repository-name') || '',
                            path: button.getAttribute('data-repository-path') || '',
                            remote: button.getAttribute('data-repository-remote') || '',
                            hasRemote: button.getAttribute('data-repository-has-remote') === 'true',
                            hasUnsynced: button.getAttribute('data-repository-unsynced') === 'true',
                            hasUncommitted: button.getAttribute('data-repository-uncommitted') === 'true',
                            hasUnpushed: button.getAttribute('data-repository-unpushed') === 'true'
                        };

                        showDeleteConfirmation(context);
                    });
                });

                const commandButtons = repositoryList.querySelectorAll('[data-repository-command]');

                commandButtons.forEach(function (button) {
                    if (button.dataset.bound === 'true') {
                        return;
                    }

                    button.dataset.bound = 'true';
                    button.addEventListener('click', function () {
                        const context = {
                            command: button.getAttribute('data-repository-command') || '',
                            name: button.getAttribute('data-repository-name') || '',
                            path: button.getAttribute('data-repository-path') || '',
                            hasRemote: button.getAttribute('data-repository-has-remote') === 'true'
                        };

                        executeRepositoryCommand(context, button);
                    });
                });
            }

            function executeRepositoryCommand(context, button) {
                if (!context || !context.command || !context.path || !button) {
                    return;
                }

                const configuration = repositoryCommandConfigurations[context.command];

                if (!configuration) {
                    return;
                }

                if (configuration.requiresRemote && context.hasRemote !== true) {
                    showGlobalNotification('Remote not configured', 'This repository does not have a remote origin configured.', 'error');
                    return;
                }

                setButtonLoading(button, true);

                const payload = {
                    repositoryPath: context.path
                };

                fetch(configuration.endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'same-origin',
                    body: JSON.stringify(payload)
                })
                    .then(function (response) {
                        if (response.ok) {
                            return response.json().catch(function () {
                                return { succeeded: true };
                            });
                        }

                        return response.json().catch(function () {
                            return { message: configuration.defaultError };
                        }).then(function (payload) {
                            const message = payload && payload.message ? payload.message : configuration.defaultError;
                            throw new Error(message);
                        });
                    })
                    .then(function (payload) {
                        const successText = payload && payload.message ? payload.message : configuration.successMessage(context);
                        showGlobalNotification(configuration.successTitle, successText, 'success');
                        refreshRepositories();
                    })
                    .catch(function (error) {
                        const failureText = error && error.message ? error.message : configuration.defaultError;
                        showGlobalNotification(configuration.errorTitle, failureText, 'error');
                    })
                    .finally(function () {
                        setButtonLoading(button, false);
                    });
            }

            function showDeleteConfirmation(context) {
                if (!context || !context.path) {
                    return;
                }

                const dialog = getDeleteDialog();
                const subtitle = dialog.querySelector('[data-dialog-subtitle]');
                const warning = dialog.querySelector('[data-dialog-warning]');
                const details = dialog.querySelector('[data-dialog-details]');
                const errorLabel = dialog.querySelector('[data-dialog-error]');
                const confirmButton = dialog.querySelector('[data-dialog-confirm]');

                repositoryDeleteContext = context;

                if (subtitle) {
                    subtitle.textContent = 'Removing "' + context.name + '" will delete its local files.';
                }

                if (warning) {
                    warning.innerHTML = buildWarningMarkup(context);
                }

                if (details) {
                    const remoteLine = context.remote && context.remote.length > 0
                        ? '<span class="block"><span class="font-semibold text-white">Remote:</span> ' + escapeHtml(context.remote) + '</span>'
                        : '<span class="block text-red-200">No remote configured.</span>';
                    details.innerHTML = '' +
                        '<span class="block"><span class="font-semibold text-white">Location:</span> ' + escapeHtml(context.path) + '</span>' +
                        remoteLine;
                }

                if (errorLabel) {
                    errorLabel.classList.add('hidden');
                    errorLabel.textContent = '';
                }

                setButtonLoading(confirmButton, false);

                dialog.classList.remove('hidden');
                dialog.classList.add('flex');
            }

            function getDeleteDialog() {
                if (repositoryDeleteDialog) {
                    return repositoryDeleteDialog;
                }

                const overlay = document.createElement('div');
                overlay.className = 'fixed inset-0 z-50 hidden items-center justify-center bg-black/60 px-4 py-6';
                overlay.setAttribute('data-repository-delete-dialog', 'true');
                overlay.innerHTML = '' +
                    '<div class="w-full max-w-lg space-y-5 rounded-2xl bg-gray-900 p-6 shadow-xl">' +
                    '  <div>' +
                    '    <h3 class="text-lg font-semibold text-white">Remove repository</h3>' +
                    '    <p class="mt-1 text-sm text-gray-300" data-dialog-subtitle></p>' +
                    '  </div>' +
                    '  <div data-dialog-warning></div>' +
                    '  <div class="space-y-1 rounded-lg border border-white/10 bg-black/40 p-3 text-xs text-gray-300" data-dialog-details></div>' +
                    '  <div class="flex justify-end gap-3">' +
                    '    <button type="button" class="inline-flex items-center justify-center rounded-md border border-white/10 bg-white/10 px-4 py-2 text-xs font-semibold text-gray-200 transition hover:bg-white/20 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-500" data-dialog-cancel>Cancel</button>' +
                    '    <button type="button" class="inline-flex items-center justify-center rounded-md border border-red-500/60 bg-red-500/20 px-4 py-2 text-xs font-semibold text-red-100 transition hover:bg-red-500/30 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-red-500" data-dialog-confirm>Delete repository</button>' +
                    '  </div>' +
                    '  <p class="hidden text-xs text-red-300" data-dialog-error></p>' +
                    '</div>';

                document.body.append(overlay);

                const cancelButton = overlay.querySelector('[data-dialog-cancel]');
                const confirmButton = overlay.querySelector('[data-dialog-confirm]');

                if (cancelButton) {
                    cancelButton.addEventListener('click', function () {
                        hideDeleteDialog();
                    });
                }

                if (confirmButton) {
                    confirmButton.addEventListener('click', function () {
                        if (repositoryDeleteContext) {
                            requestRepositoryDeletion(repositoryDeleteContext);
                        }
                    });
                }

                overlay.addEventListener('click', function (event) {
                    if (event.target === overlay) {
                        hideDeleteDialog();
                    }
                });

                if (!repositoryDeleteEscapeBound) {
                    document.addEventListener('keydown', function (event) {
                        if (event.key === 'Escape' && repositoryDeleteDialog && !repositoryDeleteDialog.classList.contains('hidden')) {
                            hideDeleteDialog();
                        }
                    });
                    repositoryDeleteEscapeBound = true;
                }

                repositoryDeleteDialog = overlay;
                return overlay;
            }

            function hideDeleteDialog() {
                if (!repositoryDeleteDialog) {
                    return;
                }

                const confirmButton = repositoryDeleteDialog.querySelector('[data-dialog-confirm]');
                const errorLabel = repositoryDeleteDialog.querySelector('[data-dialog-error]');

                setButtonLoading(confirmButton, false);

                if (errorLabel) {
                    errorLabel.classList.add('hidden');
                    errorLabel.textContent = '';
                }

                repositoryDeleteDialog.classList.add('hidden');
                repositoryDeleteDialog.classList.remove('flex');
                repositoryDeleteContext = null;
            }

            function buildWarningMarkup(context) {
                const lines = [];
                lines.push('The repository <span class="font-semibold">' + escapeHtml(context.name) + '</span> will be removed from this workspace.');

                if (!context.hasRemote) {
                    lines.push('This repository is not linked to a remote. The information cannot be recovered after deletion.');
                }

                if (context.hasUncommitted) {
                    lines.push('Uncommited changes in current branch.');
                }

                if (context.hasUnpushed) {
                    lines.push('There are commits not synchronized with origin. They will be deleted.');
                }

                if (!context.hasUncommitted && !context.hasUnpushed) {
                    lines.push('All changes appear to be synchronized, but this action is still permanent.');
                }

                lines.push('Please confirm that you want to proceed.');

                return '' +
                    '<div class="border-l-4 border-yellow-500 bg-yellow-500/10 p-4">' +
                    '  <div class="flex">' +
                    '    <div class="shrink-0">' +
                    '      <svg viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="size-5 text-yellow-500">' +
                    '        <path d="M8.485 2.495c.673-1.167 2.357-1.167 3.03 0l6.28 10.875c.673 1.167-.17 2.625-1.516 2.625H3.72c-1.347 0-2.189-1.458-1.515-2.625L8.485 2.495ZM10 5a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5A.75.75 0 0 1 10 5Zm0 9a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z" clip-rule="evenodd" fill-rule="evenodd"></path>' +
                    '      </svg>' +
                    '    </div>' +
                    '    <div class="ml-3">' +
                    '      <p class="text-sm text-yellow-300">' + lines.map(function (line) { return '<span class="block">' + line + '</span>'; }).join('') + '</p>' +
                    '    </div>' +
                    '  </div>' +
                    '</div>';
            }

            function escapeHtml(value) {
                if (value === undefined || value === null) {
                    return '';
                }

                return value
                    .toString()
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }

            function requestRepositoryDeletion(context) {
                if (!context || !context.path) {
                    return;
                }

                const dialog = repositoryDeleteDialog;
                if (!dialog) {
                    return;
                }

                const confirmButton = dialog.querySelector('[data-dialog-confirm]');
                const errorLabel = dialog.querySelector('[data-dialog-error]');

                setButtonLoading(confirmButton, true);

                if (errorLabel) {
                    errorLabel.classList.add('hidden');
                    errorLabel.textContent = '';
                }

                fetch('/api/repositories', {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'same-origin',
                    body: JSON.stringify({ repositoryPath: context.path })
                })
                    .then(function (response) {
                        if (response.ok) {
                            return response.json().catch(function () {
                                return { succeeded: true };
                            });
                        }

                        return response.json().catch(function () {
                            return { message: 'Failed to delete repository.' };
                        }).then(function (payload) {
                            const message = payload && payload.message ? payload.message : 'Failed to delete repository.';
                            throw new Error(message);
                        });
                    })
                    .then(function () {
                        hideDeleteDialog();
                        refreshRepositories();
                    })
                    .catch(function (error) {
                        if (errorLabel) {
                            errorLabel.textContent = error.message || 'Failed to delete repository.';
                            errorLabel.classList.remove('hidden');
                        }
                    })
                    .finally(function () {
                        setButtonLoading(confirmButton, false);
                    });
            }

            function setButtonLoading(button, loading) {
                if (!button) {
                    return;
                }

                if (loading) {
                    button.setAttribute('disabled', 'disabled');
                    button.classList.add('opacity-70');
                } else {
                    button.removeAttribute('disabled');
                    button.classList.remove('opacity-70');
                }
            }

            function bindClose(entry) {
                if (!entry.closeButton || entry.closeButton.dataset.bound === 'true') {
                    return;
                }

                entry.closeButton.dataset.bound = 'true';
                entry.closeButton.addEventListener('click', function () {
                    removeOperationEntry(entry);
                });
            }

            function bindCancel(entry) {
                if (!entry || !entry.cancelButton || entry.cancelButton.dataset.bound === 'true') {
                    return;
                }

                entry.cancelButton.dataset.bound = 'true';
                entry.cancelButton.addEventListener('click', function () {
                    if (!entry.operationId || entry.operationId === '00000000-0000-0000-0000-000000000000') {
                        return;
                    }

                    if (entry.messageParagraph) {
                        entry.messageParagraph.textContent = 'Stopping repository clone...';
                    }

                    setCancelButtonState(entry.cancelButton, true);
                    cancelClone(entry.operationId, entry);
                });
            }

            function cancelClone(operationId, entry) {
                fetch('/api/repositories/clone/' + operationId, {
                    method: 'DELETE',
                    credentials: 'same-origin'
                })
                    .then(function (response) {
                        if (response.status === 202 || response.status === 200) {
                            return response.text().then(function (text) {
                                if (!text) {
                                    return null;
                                }

                                try {
                                    return JSON.parse(text);
                                } catch (error) {
                                    return null;
                                }
                            });
                        }

                        return response.json().catch(function () {
                            return { message: 'Failed to cancel clone.' };
                        }).then(function (payload) {
                            const message = payload && payload.message ? payload.message : 'Failed to cancel clone.';
                            throw new Error(message);
                        });
                    })
                    .then(function (payload) {
                        if (payload) {
                            const viewState = convertStatusToViewState(payload);
                            upsertOperation(viewState);
                        }
                    })
                    .catch(function (error) {
                        if (entry && entry.messageParagraph) {
                            entry.messageParagraph.textContent = error.message || 'Failed to cancel clone.';
                        }
                    })
                    .finally(function () {
                        setCancelButtonState(entry.cancelButton, false);
                    });
            }

            function setCancelButtonState(button, loading) {
                if (!button) {
                    return;
                }

                if (loading) {
                    button.setAttribute('disabled', 'disabled');
                    button.classList.add('opacity-70');
                } else {
                    button.removeAttribute('disabled');
                    button.classList.remove('opacity-70');
                }
            }

            function removeOperationEntry(entry) {
                if (!entry) {
                    return;
                }

                if (entry.card && entry.card.parentElement) {
                    entry.card.parentElement.removeChild(entry.card);
                }

                if (entry.key && operations.has(entry.key)) {
                    operations.delete(entry.key);
                }

                scheduleRepositoryRefresh();
            }

            function formatRepositoryCount(count) {
                return count + ' repositor' + (count === 1 ? 'y' : 'ies') + ' available';
            }

            function scheduleRepositoryRefresh() {
                if (reloadTimerId !== null) {
                    return;
                }

                reloadTimerId = window.setTimeout(function () {
                    refreshRepositories();
                    reloadTimerId = null;
                }, 600);
            }

            function computeBadgeInfo(stateName, isActive) {
                const normalized = (stateName || '').toLowerCase();
                let badgeText = 'In progress';
                let badgeClass = 'inline-flex items-center gap-2 rounded-full border border-indigo-500/40 bg-indigo-500/20 px-2 py-1 text-xs font-semibold text-indigo-200';
                let progressClass = 'bg-indigo-500';

                if (normalized === 'completed') {
                    badgeText = isActive ? 'Completed' : 'Ready';
                    badgeClass = 'inline-flex items-center gap-2 rounded-full border border-emerald-500/50 bg-emerald-500/20 px-2 py-1 text-xs font-semibold text-emerald-200';
                    progressClass = 'bg-emerald-500';
                } else if (normalized === 'failed') {
                    badgeText = 'Failed';
                    badgeClass = 'inline-flex items-center gap-2 rounded-full border border-red-500/50 bg-red-500/20 px-2 py-1 text-xs font-semibold text-red-200';
                    progressClass = 'bg-red-500';
                } else if (normalized === 'canceled') {
                    badgeText = 'Canceled';
                    badgeClass = 'inline-flex items-center gap-2 rounded-full border border-yellow-500/50 bg-yellow-500/20 px-2 py-1 text-xs font-semibold text-yellow-200';
                    progressClass = 'bg-yellow-500';
                } else if (normalized === 'queued') {
                    badgeText = 'Queued';
                }

                return {
                    badgeText: badgeText,
                    badgeClass: badgeClass,
                    progressClass: progressClass
                };
            }

            function clampPercentage(value) {
                if (!Number.isFinite(value)) {
                    return 0;
                }

                if (value < 0) {
                    return 0;
                }

                if (value > 100) {
                    return 100;
                }

                return value;
            }
        });
    </script>
    <partial name="_ValidationScriptsPartial" />
}
