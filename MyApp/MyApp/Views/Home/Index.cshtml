@model MyApp.Models.Home.HomeIndexViewModel
@using System.Text.Json
@using System.Text.Json.Serialization

@{
    ViewData["Title"] = "Repositories";
    JsonSerializerOptions cloneSerializerOptions = new JsonSerializerOptions
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };
    cloneSerializerOptions.Converters.Add(new JsonStringEnumConverter());
    string initialCloneJson = JsonSerializer.Serialize(Model.CloneProgressItems, cloneSerializerOptions);
}

<section class="mx-auto max-w-6xl space-y-10 py-8">
    <div class="rounded-2xl border border-white/10 bg-gray-900/70 p-8 shadow-inner shadow-black/30">
        <h1 class="text-2xl font-semibold text-white">Repository workspace</h1>
        <p class="mt-2 text-sm text-gray-300">Clone repositories to start building their flowcharts.</p>

        <form asp-action="AddRepository" method="post" class="mt-6 space-y-4" data-clone-form="true">
            @Html.AntiForgeryToken()
            <div>
                <label asp-for="AddRepository.RepositoryUrl" class="block text-sm font-medium text-gray-200"></label>
                <div class="mt-2 flex flex-col gap-2 sm:flex-row">
                    <input asp-for="AddRepository.RepositoryUrl" class="w-full rounded-lg border border-white/10 bg-black/40 px-4 py-2 text-sm text-gray-100 placeholder-gray-500 focus:border-indigo-400 focus:outline-none focus:ring-2 focus:ring-indigo-400/40" placeholder="https://github.com/owner/repository.git" data-clone-input="true" />
                    <button type="submit" class="inline-flex items-center justify-center rounded-lg bg-indigo-500 px-4 py-2 text-sm font-semibold text-white shadow-sm transition hover:bg-indigo-400 focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:ring-offset-2 focus:ring-offset-gray-900" data-clone-submit="true">Clone repository</button>
                </div>
                <span asp-validation-for="AddRepository.RepositoryUrl" class="mt-1 block text-sm text-red-300" data-clone-error="true"></span>
            </div>
            <div class="rounded-lg border border-dashed border-white/10 bg-black/30 p-4 text-xs text-gray-400">
                Provide the HTTPS URL for the repository. Private repositories that your GitHub identity can access are supported.
            </div>
        </form>

        @if (!string.IsNullOrWhiteSpace(Model.Notification))
        {
            <div class="mt-6 rounded-lg border border-emerald-500/40 bg-emerald-500/10 p-4 text-sm text-emerald-200">
                <span class="font-semibold">Repository update:</span> @Model.Notification
            </div>
        }

        <div class="mt-6 space-y-4" data-clone-status-list="true"></div>
        <script type="application/json" id="clone-progress-data">@Html.Raw(initialCloneJson)</script>
    </div>

    <div class="rounded-2xl border border-white/10 bg-gray-900/70 p-8 shadow-inner shadow-black/30">
        <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div>
                <h2 class="text-xl font-semibold text-white">Cloned repositories</h2>
                <p class="text-sm text-gray-300">Select a repository to inspect its available branches.</p>
            </div>
            <span class="text-sm text-gray-400" data-repository-count="true" data-count="@Model.Repositories.Count">@Model.Repositories.Count repository@(Model.Repositories.Count == 1 ? string.Empty : "ies") available</span>
        </div>
        <div class="mt-8" data-repository-list="true">
            @await Html.PartialAsync("_RepositoryList", Model.Repositories)
        </div>
    </div>
</section>

@section Scripts {
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const cloneForm = document.querySelector('[data-clone-form="true"]');
            const cloneInput = document.querySelector('[data-clone-input="true"]');
            const cloneSubmit = document.querySelector('[data-clone-submit="true"]');
            const cloneError = document.querySelector('[data-clone-error="true"]');
            const cloneList = document.querySelector('[data-clone-status-list="true"]');
            const repositoryList = document.querySelector('[data-repository-list="true"]');
            const repositoryCountLabel = document.querySelector('[data-repository-count="true"]');
            const initialDataElement = document.getElementById('clone-progress-data');

            if (!cloneList) {
                return;
            }

            const operations = new Map();
            let reloadTimerId = null;
            let repositoryDeleteDialog = null;
            let repositoryDeleteContext = null;
            let repositoryDeleteEscapeBound = false;

            if (repositoryCountLabel && repositoryCountLabel.dataset.count) {
                const initialCount = parseInt(repositoryCountLabel.dataset.count || '0', 10) || 0;
                repositoryCountLabel.textContent = formatRepositoryCount(initialCount);
            }

            const initialStates = parseInitialStates(initialDataElement);

            if (initialStates.length > 0) {
                initialStates.forEach(function (state) {
                    upsertOperation(state);
                });
            }

            refreshFromServer();
            initializeRepositoryActions();

            if (cloneForm && cloneInput && cloneSubmit) {
                cloneForm.addEventListener('submit', function (event) {
                    event.preventDefault();
                    beginCloneFromForm();
                });
            }

            function parseInitialStates(scriptElement) {
                if (!scriptElement || !scriptElement.textContent) {
                    return [];
                }

                try {
                    const parsed = JSON.parse(scriptElement.textContent);
                    return Array.isArray(parsed) ? parsed : [];
                } catch (error) {
                    console.warn('Unable to parse initial clone state payload.', error);
                    return [];
                }
            }

            function beginCloneFromForm() {
                const repositoryUrl = cloneInput ? cloneInput.value.trim() : '';

                if (!repositoryUrl) {
                    showError('Please provide a repository URL.');
                    return;
                }

                showError('');
                setFormDisabled(true);

                const payload = {
                    repositoryUrl: repositoryUrl
                };

                fetch('/api/repositories/clone', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'same-origin',
                    body: JSON.stringify(payload)
                })
                    .then(function (response) {
                        if (!response.ok && response.status !== 202) {
                            return response.json().then(function (data) {
                                const message = data && data.message ? data.message : 'Failed to queue repository clone.';
                                throw new Error(message);
                            }).catch(function (error) {
                                throw new Error(error.message || 'Failed to queue repository clone.');
                            });
                        }

                        return response.json();
                    })
                    .then(function (data) {
                        if (!data) {
                            throw new Error('Unexpected response from the server.');
                        }

                        if (cloneInput) {
                            cloneInput.value = '';
                        }

                        const state = convertApiResponseToState(data);
                        upsertOperation(state);
                    })
                    .catch(function (error) {
                        showError(error.message || 'Failed to queue repository clone.');
                    })
                    .finally(function () {
                        setFormDisabled(false);
                    });
            }

            function refreshFromServer() {
                fetch('/api/repositories/clone', { cache: 'no-store', credentials: 'same-origin' })
                    .then(function (response) {
                        if (!response.ok) {
                            throw new Error('Unable to load repository clone status list.');
                        }

                        return response.json();
                    })
                    .then(function (payload) {
                        if (!payload || !Array.isArray(payload)) {
                            return;
                        }

                        payload.forEach(function (status) {
                            const viewState = convertStatusToViewState(status);
                            upsertOperation(viewState);
                        });
                    })
                    .catch(function (error) {
                        console.warn(error);
                    });
            }

            function upsertOperation(state) {
                if (!state) {
                    return;
                }

                const key = determineOperationKey(state);

                let operationEntry = operations.get(key);

                if (!operationEntry) {
                    operationEntry = createOperationEntry(state);
                    operations.set(key, operationEntry);
                    cloneList.append(operationEntry.card);
                }

                operationEntry.key = key;
                operationEntry.operationId = state.operationId;
                bindClose(operationEntry);
                bindCancel(operationEntry);

                updateOperationEntry(operationEntry, state);

                if (state.isActive && reloadTimerId !== null) {
                    window.clearTimeout(reloadTimerId);
                    reloadTimerId = null;
                }

                if (state.operationId && state.operationId !== '00000000-0000-0000-0000-000000000000' && state.isActive) {
                    schedulePoll(operationEntry, state.operationId);
                } else {
                    stopPolling(operationEntry);
                }
            }

            function determineOperationKey(state) {
                if (state.operationId && state.operationId !== '00000000-0000-0000-0000-000000000000') {
                    return state.operationId;
                }

                if (state.repositoryUrl) {
                    return 'static:' + state.repositoryUrl.toLowerCase();
                }

                return 'static:' + Math.random().toString(36).substring(2);
            }

            function createOperationEntry(state) {
                const card = document.createElement('div');
                card.className = 'rounded-lg border border-emerald-500/40 bg-emerald-500/10 p-4 text-sm text-emerald-200';
                card.setAttribute('data-operation-card', 'true');

                const header = document.createElement('div');
                header.className = 'flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between';
                card.append(header);

                const title = document.createElement('div');
                title.className = 'flex-1 text-sm';
                header.append(title);

                const strong = document.createElement('span');
                strong.className = 'font-semibold';
                strong.textContent = 'Repository queued:';
                title.append(strong);
                title.append(' ');

                const messageSpan = document.createElement('span');
                messageSpan.setAttribute('data-notification', 'true');
                title.append(messageSpan);

                const actions = document.createElement('div');
                actions.className = 'flex items-center gap-2';
                header.append(actions);

                const badge = document.createElement('span');
                badge.setAttribute('data-status-badge', 'true');
                actions.append(badge);

                const cancelButton = document.createElement('button');
                cancelButton.type = 'button';
                cancelButton.setAttribute('data-cancel', 'true');
                cancelButton.className = 'hidden inline-flex items-center gap-1 rounded-md border border-yellow-500/50 bg-yellow-500/15 px-3 py-1 text-xs font-semibold text-yellow-200 transition hover:bg-yellow-500/25 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-yellow-500';
                cancelButton.innerHTML = '<svg viewBox=\"0 0 20 20\" fill=\"currentColor\" aria-hidden=\"true\" class=\"size-4\"><path d=\"M6.5 5A1.5 1.5 0 0 0 5 6.5v7A1.5 1.5 0 0 0 6.5 15h7a1.5 1.5 0 0 0 1.5-1.5v-7A1.5 1.5 0 0 0 13.5 5h-7Z\"></path></svg><span>Stop cloning</span>';
                actions.append(cancelButton);

                const closeButton = document.createElement('button');
                closeButton.type = 'button';
                closeButton.setAttribute('data-close', 'true');
                closeButton.className = 'hidden rounded-md border border-white/10 bg-white/5 p-1 text-gray-200 transition hover:bg-white/10 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-500';
                closeButton.innerHTML = '<span class=\"sr-only\">Dismiss notification</span><svg viewBox=\"0 0 20 20\" fill=\"currentColor\" aria-hidden=\"true\" class=\"size-4\"><path fill-rule=\"evenodd\" d=\"M4.293 4.293a1 1 0 0 1 1.414 0L10 8.586l4.293-4.293a1 1 0 1 1 1.414 1.414L11.414 10l4.293 4.293a1 1 0 0 1-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L8.586 10 4.293 5.707a1 1 0 0 1 0-1.414Z\" clip-rule=\"evenodd\"></path></svg>';
                actions.append(closeButton);

                const progressContainer = document.createElement('div');
                progressContainer.className = 'mt-4 space-y-3';
                progressContainer.setAttribute('data-progress-container', 'true');
                card.append(progressContainer);

                const stageLabel = document.createElement('p');
                stageLabel.setAttribute('data-stage-label', 'true');
                stageLabel.className = 'text-sm font-medium text-white';
                progressContainer.append(stageLabel);

                const progressBackground = document.createElement('div');
                progressBackground.className = 'overflow-hidden rounded-full bg-white/10';
                progressContainer.append(progressBackground);

                const progressBar = document.createElement('div');
                progressBar.className = 'h-2 rounded-full bg-indigo-500 transition-all duration-500 ease-out';
                progressBar.setAttribute('data-progress-bar', 'true');
                progressBar.style.width = '1%';
                progressBackground.append(progressBar);

                const progressMeta = document.createElement('div');
                progressMeta.className = 'flex items-center justify-between text-xs font-medium text-gray-400';
                progressContainer.append(progressMeta);

                const progressLabel = document.createElement('span');
                progressLabel.textContent = 'Progress';
                progressMeta.append(progressLabel);

                const progressValue = document.createElement('span');
                progressValue.setAttribute('data-progress-value', 'true');
                progressValue.textContent = '0%';
                progressMeta.append(progressValue);

                const stageGrid = document.createElement('div');
                stageGrid.className = 'mt-3 grid grid-cols-4 text-xs font-medium text-gray-400';
                stageGrid.setAttribute('data-progress-steps', 'true');
                progressContainer.append(stageGrid);

                stageGrid.innerHTML = '' +
                    '<div class="text-indigo-400" data-step="queued">Queued</div>' +
                    '<div class="text-center text-gray-400" data-step="receiving">Downloading</div>' +
                    '<div class="text-center text-gray-400" data-step="resolving">Verifying</div>' +
                    '<div class="text-right text-gray-400" data-step="completed">Ready</div>';

                const messageParagraph = document.createElement('p');
                messageParagraph.className = 'mt-3 text-xs text-gray-400';
                messageParagraph.setAttribute('data-progress-message', 'true');
                progressContainer.append(messageParagraph);

                const summaryContainer = document.createElement('div');
                summaryContainer.className = 'mt-4 rounded-md border border-white/10 bg-black/30 px-3 py-2 text-xs text-gray-200';
                summaryContainer.setAttribute('data-summary', 'true');
                summaryContainer.style.display = 'none';
                card.append(summaryContainer);

                return {
                    card: card,
                    badge: badge,
                    titleLabel: strong,
                    messageSpan: messageSpan,
                    progressContainer: progressContainer,
                    stageLabel: stageLabel,
                    progressBar: progressBar,
                    progressValue: progressValue,
                    messageParagraph: messageParagraph,
                    stepsContainer: stageGrid,
                    summaryContainer: summaryContainer,
                    pollTimerId: null,
                    closeButton: closeButton,
                    cancelButton: cancelButton,
                    isActive: state.isActive,
                    state: state.state,
                    operationId: state.operationId
                };
            }

            function updateOperationEntry(entry, state) {
                const wasActive = entry.isActive === true;
                const normalizedStage = state.stage && state.stage.length > 0 ? state.stage : 'Processing repository...';
                const normalizedMessage = state.message && state.message.length > 0 ? state.message : defaultMessageForState(state.state);
                const boundedPercentage = clampPercentage(state.percentage);
                const displayPercentage = boundedPercentage.toFixed(1) + '%';
                const info = computeBadgeInfo(state.state, state.isActive);

                if (entry.cancelButton) {
                    if (state.isActive && state.operationId && state.operationId !== '00000000-0000-0000-0000-000000000000') {
                        entry.cancelButton.classList.remove('hidden');
                        setCancelButtonState(entry.cancelButton, false);
                    } else {
                        entry.cancelButton.classList.add('hidden');
                        setCancelButtonState(entry.cancelButton, false);
                    }
                }

                entry.card.className = cardClassForState(state.state);
                entry.titleLabel.textContent = headingForState(state.state, state.isActive);
                entry.messageSpan.textContent = state.notification || state.repositoryUrl || 'Repository clone';
                entry.badge.textContent = info.badgeText;
                entry.badge.className = info.badgeClass;

                if (state.isActive) {
                    entry.progressContainer.style.display = '';
                    entry.summaryContainer.style.display = 'none';
                    if (entry.closeButton) {
                        entry.closeButton.classList.add('hidden');
                    }
                    entry.stageLabel.textContent = normalizedStage;
                    entry.progressBar.style.width = Math.max(1, Math.min(boundedPercentage, 100)).toFixed(1) + '%';
                    entry.progressBar.classList.remove('bg-indigo-500', 'bg-emerald-500', 'bg-red-500');
                    entry.progressBar.classList.add(info.progressClass);
                    entry.progressValue.textContent = displayPercentage;
                    entry.messageParagraph.textContent = normalizedMessage;
                    updateSteps(entry.stepsContainer, normalizedStage, state.state);
                } else {
                    entry.progressContainer.style.display = 'none';
                    entry.summaryContainer.style.display = '';
                    entry.summaryContainer.textContent = finalMessageForState(state.state, state.message);
                    if (entry.closeButton) {
                        entry.closeButton.classList.remove('hidden');
                    }
                    if (state.state === 'Completed') {
                        scheduleRepositoryRefresh();
                    }
                }

                entry.isActive = state.isActive;
                entry.state = state.state;
                entry.operationId = state.operationId;

                if (wasActive && !entry.isActive) {
                    scheduleRepositoryRefresh();
                }
            }

            function defaultMessageForState(stateName) {
                const normalized = (stateName || '').toLowerCase();

                if (normalized === 'failed') {
                    return 'Repository clone failed. Please verify the URL or credentials.';
                }

                if (normalized === 'completed') {
                    return 'Clone completed successfully. Preparing the repository list...';
                }

                if (normalized === 'canceled') {
                    return 'Clone canceled. Previously downloaded files have been removed.';
                }

                return 'We are cloning your repository. This usually takes less than a minute.';
            }

            function headingForState(stateName, isActive) {
                const normalized = (stateName || '').toLowerCase();

                if (normalized === 'failed') {
                    return 'Repository clone failed:';
                }

                if (normalized === 'completed') {
                    return 'Repository cloned:';
                }

                if (normalized === 'canceled') {
                    return 'Repository clone canceled:';
                }

                if (normalized === 'running' && isActive) {
                    return 'Repository cloning:';
                }

                return 'Repository queued:';
            }

            function cardClassForState(stateName) {
                const normalized = (stateName || '').toLowerCase();

                if (normalized === 'failed') {
                    return 'rounded-lg border border-red-500/40 bg-red-500/10 p-4 text-sm text-red-100';
                }

                if (normalized === 'completed') {
                    return 'rounded-lg border border-emerald-500/40 bg-emerald-500/10 p-4 text-sm text-emerald-200';
                }

                if (normalized === 'canceled') {
                    return 'rounded-lg border border-yellow-500/40 bg-yellow-500/10 p-4 text-sm text-yellow-200';
                }

                return 'rounded-lg border border-indigo-500/40 bg-indigo-500/10 p-4 text-sm text-indigo-100';
            }

            function finalMessageForState(stateName, message) {
                if (message && message.length > 0) {
                    return message;
                }

                const normalized = (stateName || '').toLowerCase();

                if (normalized === 'completed') {
                    return 'Clone completed successfully.';
                }

                if (normalized === 'failed') {
                    return 'Clone failed. Please review the repository URL or credentials.';
                }

                if (normalized === 'canceled') {
                    return 'Clone canceled. Local data was removed.';
                }

                return 'Clone status updated.';
            }

            function schedulePoll(entry, operationId) {
                stopPolling(entry);

                entry.pollTimerId = window.setTimeout(function () {
                    pollOperation(entry, operationId);
                }, 1500);
            }

            function stopPolling(entry) {
                if (entry.pollTimerId !== null) {
                    window.clearTimeout(entry.pollTimerId);
                    entry.pollTimerId = null;
                }
            }

            function pollOperation(entry, operationId) {
                fetch('/api/repositories/clone/' + operationId, { cache: 'no-store', credentials: 'same-origin' })
                    .then(function (response) {
                        if (!response.ok) {
                            throw new Error('Status response not available.');
                        }

                        return response.json();
                    })
                    .then(function (payload) {
                        if (!payload) {
                            return;
                        }

                        const viewState = convertStatusToViewState(payload);
                        upsertOperation(viewState);
                    })
                    .catch(function () {
                        // retry with back-off
                        schedulePoll(entry, operationId);
                    });
            }

            function showError(message) {
                if (cloneError) {
                    cloneError.textContent = message || '';
                }
            }

            function setFormDisabled(disabled) {
                if (!cloneSubmit) {
                    return;
                }

                if (disabled) {
                    cloneSubmit.setAttribute('disabled', 'disabled');
                    cloneSubmit.classList.add('opacity-70');
                } else {
                    cloneSubmit.removeAttribute('disabled');
                    cloneSubmit.classList.remove('opacity-70');
                }
            }

            function updateSteps(container, stageText, stateName) {
                if (!container) {
                    return;
                }

                const normalizedStage = (stageText || '').toLowerCase();
                const normalizedState = (stateName || '').toLowerCase();
                const stepElements = container.querySelectorAll('[data-step]');

                stepElements.forEach(function (element) {
                    const step = element.getAttribute('data-step');

                    if (!step) {
                        return;
                    }

                    let active = false;

                    switch (step) {
                        case 'queued':
                            active = true;
                            break;
                        case 'receiving':
                            active = normalizedStage.includes('receiving') || normalizedStage.includes('transfer');
                            break;
                        case 'resolving':
                            active = normalizedStage.includes('resolving') || normalizedStage.includes('index');
                            break;
                        case 'completed':
                            active = normalizedStage.includes('complete') || normalizedStage.includes('ready') || normalizedState === 'completed';
                            break;
                        default:
                            active = false;
                            break;
                    }

                    element.classList.remove('text-indigo-400', 'text-emerald-400');

                    if (active) {
                        element.classList.remove('text-gray-400');

                        if (step === 'completed' && normalizedState === 'completed') {
                            element.classList.add('text-emerald-400');
                        } else {
                            element.classList.add('text-indigo-400');
                        }
                    } else {
                        element.classList.add('text-gray-400');
                    }
                });
            }

            function convertApiResponseToState(response) {
                const status = response.status || null;
                const operationId = status && status.operationId ? status.operationId : response.operationId || '';
                const percentage = status && typeof status.percentage === 'number'
                    ? status.percentage
                    : (status && status.percentage ? parseFloat(status.percentage) : 0);
                const stage = status && status.stage ? status.stage : '';
                const message = status && status.message ? status.message : '';
                const stateName = status && status.state ? status.state : (response.alreadyCloned ? 'Completed' : 'Queued');
                const notification = response.notification || response.repositoryUrl || 'Repository clone';

                return {
                    operationId: operationId,
                    repositoryUrl: response.repositoryUrl || '',
                    notification: notification,
                    percentage: percentage,
                    stage: stage,
                    message: message,
                    state: stateName,
                    isActive: stateName === 'Queued' || stateName === 'Running'
                };
            }

            function convertStatusToViewState(status) {
                const stateName = status.state || 'Queued';

                return {
                    operationId: status.operationId || '',
                    repositoryUrl: status.repositoryUrl || '',
                    notification: status.repositoryUrl || 'Repository clone',
                    percentage: typeof status.percentage === 'number' ? status.percentage : parseFloat(status.percentage || '0') || 0,
                    stage: status.stage || '',
                    message: status.message || '',
                    state: stateName,
                    isActive: stateName === 'Queued' || stateName === 'Running'
                };
            }

            function refreshRepositories() {
                if (!repositoryList) {
                    return;
                }

                fetch('/Home/RepositoryList', {
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    credentials: 'same-origin'
                })
                    .then(function (response) {
                        if (!response.ok) {
                            throw new Error('Unable to refresh repository list.');
                        }

                        return response.text();
                    })
                    .then(function (html) {
                        const parser = new DOMParser();
                        const documentFragment = parser.parseFromString(html, 'text/html');
                        const payload = documentFragment.querySelector('[data-repository-payload]');

                        if (!payload) {
                            return;
                        }

                        repositoryList.innerHTML = payload.innerHTML;
                        initializeRepositoryActions();

                        const countAttribute = payload.getAttribute('data-count');
                        const repositoryCount = parseInt(countAttribute || '0', 10) || 0;

                        if (repositoryCountLabel) {
                            repositoryCountLabel.textContent = formatRepositoryCount(repositoryCount);
                            repositoryCountLabel.dataset.count = repositoryCount.toString();
                        }
                    })
                    .catch(function (error) {
                        console.warn(error);
                    });
            }

            function initializeRepositoryActions() {
                if (!repositoryList) {
                    return;
                }

                const deleteButtons = repositoryList.querySelectorAll('[data-repository-delete="true"]');

                deleteButtons.forEach(function (button) {
                    if (button.dataset.bound === 'true') {
                        return;
                    }

                    button.dataset.bound = 'true';
                    button.addEventListener('click', function () {
                        const context = {
                            name: button.getAttribute('data-repository-name') || '',
                            path: button.getAttribute('data-repository-path') || '',
                            remote: button.getAttribute('data-repository-remote') || '',
                            hasRemote: button.getAttribute('data-repository-has-remote') === 'true',
                            hasUnsynced: button.getAttribute('data-repository-unsynced') === 'true',
                            hasUncommitted: button.getAttribute('data-repository-uncommitted') === 'true',
                            hasUnpushed: button.getAttribute('data-repository-unpushed') === 'true'
                        };

                        showDeleteConfirmation(context);
                    });
                });
            }

            function showDeleteConfirmation(context) {
                if (!context || !context.path) {
                    return;
                }

                const dialog = getDeleteDialog();
                const subtitle = dialog.querySelector('[data-dialog-subtitle]');
                const warning = dialog.querySelector('[data-dialog-warning]');
                const details = dialog.querySelector('[data-dialog-details]');
                const errorLabel = dialog.querySelector('[data-dialog-error]');
                const confirmButton = dialog.querySelector('[data-dialog-confirm]');

                repositoryDeleteContext = context;

                if (subtitle) {
                    subtitle.textContent = 'Removing "' + context.name + '" will delete its local files.';
                }

                if (warning) {
                    warning.innerHTML = buildWarningMarkup(context);
                }

                if (details) {
                    const remoteLine = context.remote && context.remote.length > 0
                        ? '<span class="block"><span class="font-semibold text-white">Remote:</span> ' + escapeHtml(context.remote) + '</span>'
                        : '<span class="block text-red-200">No remote configured.</span>';
                    details.innerHTML = '' +
                        '<span class="block"><span class="font-semibold text-white">Location:</span> ' + escapeHtml(context.path) + '</span>' +
                        remoteLine;
                }

                if (errorLabel) {
                    errorLabel.classList.add('hidden');
                    errorLabel.textContent = '';
                }

                setButtonLoading(confirmButton, false);

                dialog.classList.remove('hidden');
                dialog.classList.add('flex');
            }

            function getDeleteDialog() {
                if (repositoryDeleteDialog) {
                    return repositoryDeleteDialog;
                }

                const overlay = document.createElement('div');
                overlay.className = 'fixed inset-0 z-50 hidden items-center justify-center bg-black/60 px-4 py-6';
                overlay.setAttribute('data-repository-delete-dialog', 'true');
                overlay.innerHTML = '' +
                    '<div class="w-full max-w-lg space-y-5 rounded-2xl bg-gray-900 p-6 shadow-xl">' +
                    '  <div>' +
                    '    <h3 class="text-lg font-semibold text-white">Remove repository</h3>' +
                    '    <p class="mt-1 text-sm text-gray-300" data-dialog-subtitle></p>' +
                    '  </div>' +
                    '  <div data-dialog-warning></div>' +
                    '  <div class="space-y-1 rounded-lg border border-white/10 bg-black/40 p-3 text-xs text-gray-300" data-dialog-details></div>' +
                    '  <div class="flex justify-end gap-3">' +
                    '    <button type="button" class="inline-flex items-center justify-center rounded-md border border-white/10 bg-white/10 px-4 py-2 text-xs font-semibold text-gray-200 transition hover:bg-white/20 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-500" data-dialog-cancel>Cancel</button>' +
                    '    <button type="button" class="inline-flex items-center justify-center rounded-md border border-red-500/60 bg-red-500/20 px-4 py-2 text-xs font-semibold text-red-100 transition hover:bg-red-500/30 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-red-500" data-dialog-confirm>Delete repository</button>' +
                    '  </div>' +
                    '  <p class="hidden text-xs text-red-300" data-dialog-error></p>' +
                    '</div>';

                document.body.append(overlay);

                const cancelButton = overlay.querySelector('[data-dialog-cancel]');
                const confirmButton = overlay.querySelector('[data-dialog-confirm]');

                if (cancelButton) {
                    cancelButton.addEventListener('click', function () {
                        hideDeleteDialog();
                    });
                }

                if (confirmButton) {
                    confirmButton.addEventListener('click', function () {
                        if (repositoryDeleteContext) {
                            requestRepositoryDeletion(repositoryDeleteContext);
                        }
                    });
                }

                overlay.addEventListener('click', function (event) {
                    if (event.target === overlay) {
                        hideDeleteDialog();
                    }
                });

                if (!repositoryDeleteEscapeBound) {
                    document.addEventListener('keydown', function (event) {
                        if (event.key === 'Escape' && repositoryDeleteDialog && !repositoryDeleteDialog.classList.contains('hidden')) {
                            hideDeleteDialog();
                        }
                    });
                    repositoryDeleteEscapeBound = true;
                }

                repositoryDeleteDialog = overlay;
                return overlay;
            }

            function hideDeleteDialog() {
                if (!repositoryDeleteDialog) {
                    return;
                }

                const confirmButton = repositoryDeleteDialog.querySelector('[data-dialog-confirm]');
                const errorLabel = repositoryDeleteDialog.querySelector('[data-dialog-error]');

                setButtonLoading(confirmButton, false);

                if (errorLabel) {
                    errorLabel.classList.add('hidden');
                    errorLabel.textContent = '';
                }

                repositoryDeleteDialog.classList.add('hidden');
                repositoryDeleteDialog.classList.remove('flex');
                repositoryDeleteContext = null;
            }

            function buildWarningMarkup(context) {
                const lines = [];
                lines.push('The repository <span class="font-semibold">' + escapeHtml(context.name) + '</span> will be removed from this workspace.');

                if (!context.hasRemote) {
                    lines.push('This repository is not linked to a remote. The information cannot be recovered after deletion.');
                }

                if (context.hasUncommitted) {
                    lines.push('Uncommitted changes exist locally and will be lost.');
                }

                if (context.hasUnpushed) {
                    lines.push('There are commits not synchronized with origin. They will be deleted.');
                }

                if (!context.hasUncommitted && !context.hasUnpushed) {
                    lines.push('All changes appear to be synchronized, but this action is still permanent.');
                }

                lines.push('Please confirm that you want to proceed.');

                return '' +
                    '<div class="border-l-4 border-yellow-500 bg-yellow-500/10 p-4">' +
                    '  <div class="flex">' +
                    '    <div class="shrink-0">' +
                    '      <svg viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="size-5 text-yellow-500">' +
                    '        <path d="M8.485 2.495c.673-1.167 2.357-1.167 3.03 0l6.28 10.875c.673 1.167-.17 2.625-1.516 2.625H3.72c-1.347 0-2.189-1.458-1.515-2.625L8.485 2.495ZM10 5a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5A.75.75 0 0 1 10 5Zm0 9a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z" clip-rule="evenodd" fill-rule="evenodd"></path>' +
                    '      </svg>' +
                    '    </div>' +
                    '    <div class="ml-3">' +
                    '      <p class="text-sm text-yellow-300">' + lines.map(function (line) { return '<span class="block">' + line + '</span>'; }).join('') + '</p>' +
                    '    </div>' +
                    '  </div>' +
                    '</div>';
            }

            function escapeHtml(value) {
                if (value === undefined || value === null) {
                    return '';
                }

                return value
                    .toString()
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }

            function requestRepositoryDeletion(context) {
                if (!context || !context.path) {
                    return;
                }

                const dialog = repositoryDeleteDialog;
                if (!dialog) {
                    return;
                }

                const confirmButton = dialog.querySelector('[data-dialog-confirm]');
                const errorLabel = dialog.querySelector('[data-dialog-error]');

                setButtonLoading(confirmButton, true);

                if (errorLabel) {
                    errorLabel.classList.add('hidden');
                    errorLabel.textContent = '';
                }

                fetch('/api/repositories', {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'same-origin',
                    body: JSON.stringify({ repositoryPath: context.path })
                })
                    .then(function (response) {
                        if (response.ok) {
                            return response.json().catch(function () {
                                return { succeeded: true };
                            });
                        }

                        return response.json().catch(function () {
                            return { message: 'Failed to delete repository.' };
                        }).then(function (payload) {
                            const message = payload && payload.message ? payload.message : 'Failed to delete repository.';
                            throw new Error(message);
                        });
                    })
                    .then(function () {
                        hideDeleteDialog();
                        refreshRepositories();
                    })
                    .catch(function (error) {
                        if (errorLabel) {
                            errorLabel.textContent = error.message || 'Failed to delete repository.';
                            errorLabel.classList.remove('hidden');
                        }
                    })
                    .finally(function () {
                        setButtonLoading(confirmButton, false);
                    });
            }

            function setButtonLoading(button, loading) {
                if (!button) {
                    return;
                }

                if (loading) {
                    button.setAttribute('disabled', 'disabled');
                    button.classList.add('opacity-70');
                } else {
                    button.removeAttribute('disabled');
                    button.classList.remove('opacity-70');
                }
            }

            function bindClose(entry) {
                if (!entry.closeButton || entry.closeButton.dataset.bound === 'true') {
                    return;
                }

                entry.closeButton.dataset.bound = 'true';
                entry.closeButton.addEventListener('click', function () {
                    removeOperationEntry(entry);
                });
            }

            function bindCancel(entry) {
                if (!entry || !entry.cancelButton || entry.cancelButton.dataset.bound === 'true') {
                    return;
                }

                entry.cancelButton.dataset.bound = 'true';
                entry.cancelButton.addEventListener('click', function () {
                    if (!entry.operationId || entry.operationId === '00000000-0000-0000-0000-000000000000') {
                        return;
                    }

                    if (entry.messageParagraph) {
                        entry.messageParagraph.textContent = 'Stopping repository clone and removing downloaded files...';
                    }

                    setCancelButtonState(entry.cancelButton, true);
                    cancelClone(entry.operationId, entry);
                });
            }

            function cancelClone(operationId, entry) {
                fetch('/api/repositories/clone/' + operationId, {
                    method: 'DELETE',
                    credentials: 'same-origin'
                })
                    .then(function (response) {
                        if (response.status === 202 || response.status === 200) {
                            return response.text().then(function (text) {
                                if (!text) {
                                    return null;
                                }

                                try {
                                    return JSON.parse(text);
                                } catch (error) {
                                    return null;
                                }
                            });
                        }

                        return response.json().catch(function () {
                            return { message: 'Failed to cancel clone.' };
                        }).then(function (payload) {
                            const message = payload && payload.message ? payload.message : 'Failed to cancel clone.';
                            throw new Error(message);
                        });
                    })
                    .then(function (payload) {
                        if (payload) {
                            const viewState = convertStatusToViewState(payload);
                            upsertOperation(viewState);
                        }
                    })
                    .catch(function (error) {
                        if (entry && entry.messageParagraph) {
                            entry.messageParagraph.textContent = error.message || 'Failed to cancel clone.';
                        }
                    })
                    .finally(function () {
                        setCancelButtonState(entry.cancelButton, false);
                    });
            }

            function setCancelButtonState(button, loading) {
                if (!button) {
                    return;
                }

                if (loading) {
                    button.setAttribute('disabled', 'disabled');
                    button.classList.add('opacity-70');
                } else {
                    button.removeAttribute('disabled');
                    button.classList.remove('opacity-70');
                }
            }

            function removeOperationEntry(entry) {
                if (!entry) {
                    return;
                }

                if (entry.card && entry.card.parentElement) {
                    entry.card.parentElement.removeChild(entry.card);
                }

                if (entry.key && operations.has(entry.key)) {
                    operations.delete(entry.key);
                }

                scheduleRepositoryRefresh();
            }

            function formatRepositoryCount(count) {
                return count + ' repository' + (count === 1 ? '' : 'ies') + ' available';
            }

            function scheduleRepositoryRefresh() {
                if (reloadTimerId !== null) {
                    return;
                }

                reloadTimerId = window.setTimeout(function () {
                    refreshRepositories();
                    reloadTimerId = null;
                }, 600);
            }

            function computeBadgeInfo(stateName, isActive) {
                const normalized = (stateName || '').toLowerCase();
                let badgeText = 'In progress';
                let badgeClass = 'inline-flex items-center gap-2 rounded-full border border-indigo-500/40 bg-indigo-500/20 px-2 py-1 text-xs font-semibold text-indigo-200';
                let progressClass = 'bg-indigo-500';

                if (normalized === 'completed') {
                    badgeText = isActive ? 'Completed' : 'Ready';
                    badgeClass = 'inline-flex items-center gap-2 rounded-full border border-emerald-500/50 bg-emerald-500/20 px-2 py-1 text-xs font-semibold text-emerald-200';
                    progressClass = 'bg-emerald-500';
                } else if (normalized === 'failed') {
                    badgeText = 'Failed';
                    badgeClass = 'inline-flex items-center gap-2 rounded-full border border-red-500/50 bg-red-500/20 px-2 py-1 text-xs font-semibold text-red-200';
                    progressClass = 'bg-red-500';
                } else if (normalized === 'canceled') {
                    badgeText = 'Canceled';
                    badgeClass = 'inline-flex items-center gap-2 rounded-full border border-yellow-500/50 bg-yellow-500/20 px-2 py-1 text-xs font-semibold text-yellow-200';
                    progressClass = 'bg-yellow-500';
                } else if (normalized === 'queued') {
                    badgeText = 'Queued';
                }

                return {
                    badgeText: badgeText,
                    badgeClass: badgeClass,
                    progressClass: progressClass
                };
            }

            function clampPercentage(value) {
                if (!Number.isFinite(value)) {
                    return 0;
                }

                if (value < 0) {
                    return 0;
                }

                if (value > 100) {
                    return 100;
                }

                return value;
            }
        });
    </script>
    <partial name="_ValidationScriptsPartial" />
}
