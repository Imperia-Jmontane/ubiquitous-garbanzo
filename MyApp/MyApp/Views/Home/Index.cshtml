@model MyApp.Models.Home.HomeIndexViewModel
@using System.Text.Json
@using System.Text.Json.Serialization

@{
    ViewData["Title"] = "Repositories";
    JsonSerializerOptions cloneSerializerOptions = new JsonSerializerOptions
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };
    cloneSerializerOptions.Converters.Add(new JsonStringEnumConverter());
    string initialCloneJson = JsonSerializer.Serialize(Model.CloneProgressItems, cloneSerializerOptions);
}

<section class="mx-auto max-w-6xl space-y-10 py-8">
    <div class="rounded-2xl border border-white/10 bg-gray-900/70 p-8 shadow-inner shadow-black/30">
        <h1 class="text-2xl font-semibold text-white">Repository workspace</h1>
        <p class="mt-2 text-sm text-gray-300">Clone repositories to start building their flowcharts.</p>

        <form asp-action="AddRepository" method="post" class="mt-6 space-y-4" data-clone-form="true">
            @Html.AntiForgeryToken()
            <div>
                <label asp-for="AddRepository.RepositoryUrl" class="block text-sm font-medium text-gray-200"></label>
                <div class="mt-2 flex flex-col gap-2 sm:flex-row">
                    <input asp-for="AddRepository.RepositoryUrl" class="w-full rounded-lg border border-white/10 bg-black/40 px-4 py-2 text-sm text-gray-100 placeholder-gray-500 focus:border-indigo-400 focus:outline-none focus:ring-2 focus:ring-indigo-400/40" placeholder="https://github.com/owner/repository.git" data-clone-input="true" />
                    <button type="submit" class="inline-flex items-center justify-center rounded-lg bg-indigo-500 px-4 py-2 text-sm font-semibold text-white shadow-sm transition hover:bg-indigo-400 focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:ring-offset-2 focus:ring-offset-gray-900" data-clone-submit="true">Clone repository</button>
                </div>
                <span asp-validation-for="AddRepository.RepositoryUrl" class="mt-1 block text-sm text-red-300" data-clone-error="true"></span>
            </div>
            <div class="rounded-lg border border-dashed border-white/10 bg-black/30 p-4 text-xs text-gray-400">
                Provide the HTTPS URL for the repository. Private repositories that your GitHub identity can access are supported.
            </div>
        </form>

        @if (!string.IsNullOrWhiteSpace(Model.Notification))
        {
            <div class="mt-6 rounded-lg border border-emerald-500/40 bg-emerald-500/10 p-4 text-sm text-emerald-200">
                <span class="font-semibold">Repository update:</span> @Model.Notification
            </div>
        }

        <div class="mt-6 space-y-4" data-clone-status-list="true"></div>
        <script type="application/json" id="clone-progress-data">@Html.Raw(initialCloneJson)</script>
    </div>

    <div class="rounded-2xl border border-white/10 bg-gray-900/70 p-8 shadow-inner shadow-black/30">
        <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <div>
                <h2 class="text-xl font-semibold text-white">Cloned repositories</h2>
                <p class="text-sm text-gray-300">Select a repository to inspect its available branches.</p>
            </div>
            <span class="text-sm text-gray-400" data-repository-count="true" data-count="@Model.Repositories.Count">@Model.Repositories.Count repository@(Model.Repositories.Count == 1 ? string.Empty : "ies") available</span>
        </div>
        <div class="mt-8" data-repository-list="true">
            @await Html.PartialAsync("_RepositoryList", Model.Repositories)
        </div>
        <div class="mt-4 hidden rounded-lg border border-white/10 bg-black/40 p-4 text-sm text-gray-200" data-repository-feedback="true"></div>
    </div>
</section>

@section Scripts {
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const cloneForm = document.querySelector('[data-clone-form="true"]');
            const cloneInput = document.querySelector('[data-clone-input="true"]');
            const cloneSubmit = document.querySelector('[data-clone-submit="true"]');
            const cloneError = document.querySelector('[data-clone-error="true"]');
            const cloneList = document.querySelector('[data-clone-status-list="true"]');
            const repositoryList = document.querySelector('[data-repository-list="true"]');
            const repositoryCountLabel = document.querySelector('[data-repository-count="true"]');
            const repositoryFeedback = document.querySelector('[data-repository-feedback="true"]');
            const initialDataElement = document.getElementById('clone-progress-data');

            if (!cloneList) {
                return;
            }

            const operations = new Map();
            let reloadTimerId = null;

            if (repositoryCountLabel && repositoryCountLabel.dataset.count) {
                const initialCount = parseInt(repositoryCountLabel.dataset.count || '0', 10) || 0;
                repositoryCountLabel.textContent = formatRepositoryCount(initialCount);
            }

            const initialStates = parseInitialStates(initialDataElement);

            if (initialStates.length > 0) {
                initialStates.forEach(function (state) {
                    upsertOperation(state);
                });
            }

            refreshFromServer();
            bindRepositoryActions();

            if (cloneForm && cloneInput && cloneSubmit) {
                cloneForm.addEventListener('submit', function (event) {
                    event.preventDefault();
                    beginCloneFromForm();
                });
            }

            function parseInitialStates(scriptElement) {
                if (!scriptElement || !scriptElement.textContent) {
                    return [];
                }

                try {
                    const parsed = JSON.parse(scriptElement.textContent);
                    return Array.isArray(parsed) ? parsed : [];
                } catch (error) {
                    console.warn('Unable to parse initial clone state payload.', error);
                    return [];
                }
            }

            function beginCloneFromForm() {
                const repositoryUrl = cloneInput ? cloneInput.value.trim() : '';

                if (!repositoryUrl) {
                    showError('Please provide a repository URL.');
                    return;
                }

                showError('');
                setFormDisabled(true);

                const payload = {
                    repositoryUrl: repositoryUrl
                };

                fetch('/api/repositories/clone', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'same-origin',
                    body: JSON.stringify(payload)
                })
                    .then(function (response) {
                        if (!response.ok && response.status !== 202) {
                            return response.json().then(function (data) {
                                const message = data && data.message ? data.message : 'Failed to queue repository clone.';
                                throw new Error(message);
                            }).catch(function (error) {
                                throw new Error(error.message || 'Failed to queue repository clone.');
                            });
                        }

                        return response.json();
                    })
                    .then(function (data) {
                        if (!data) {
                            throw new Error('Unexpected response from the server.');
                        }

                        if (cloneInput) {
                            cloneInput.value = '';
                        }

                        const state = convertApiResponseToState(data);
                        upsertOperation(state);
                    })
                    .catch(function (error) {
                        showError(error.message || 'Failed to queue repository clone.');
                    })
                    .finally(function () {
                        setFormDisabled(false);
                    });
            }

            function refreshFromServer() {
                fetch('/api/repositories/clone', { cache: 'no-store', credentials: 'same-origin' })
                    .then(function (response) {
                        if (!response.ok) {
                            throw new Error('Unable to load repository clone status list.');
                        }

                        return response.json();
                    })
                    .then(function (payload) {
                        if (!payload || !Array.isArray(payload)) {
                            return;
                        }

                        payload.forEach(function (status) {
                            const viewState = convertStatusToViewState(status);
                            upsertOperation(viewState);
                        });
                    })
                    .catch(function (error) {
                        console.warn(error);
                    });
            }

            function upsertOperation(state) {
                if (!state) {
                    return;
                }

                const key = determineOperationKey(state);

                let operationEntry = operations.get(key);

                if (!operationEntry) {
                    operationEntry = createOperationEntry(state);
                    operations.set(key, operationEntry);
                    cloneList.append(operationEntry.card);
                }

                operationEntry.key = key;
                operationEntry.operationId = state.operationId;
                operationEntry.repositoryUrl = state.repositoryUrl;
                bindClose(operationEntry);
                bindCancel(operationEntry);

                updateOperationEntry(operationEntry, state);

                if (state.isActive && reloadTimerId !== null) {
                    window.clearTimeout(reloadTimerId);
                    reloadTimerId = null;
                }

                if (state.operationId && state.operationId !== '00000000-0000-0000-0000-000000000000' && state.isActive) {
                    schedulePoll(operationEntry, state.operationId);
                } else {
                    stopPolling(operationEntry);
                }
            }

            function determineOperationKey(state) {
                if (state.operationId && state.operationId !== '00000000-0000-0000-0000-000000000000') {
                    return state.operationId;
                }

                if (state.repositoryUrl) {
                    return 'static:' + state.repositoryUrl.toLowerCase();
                }

                return 'static:' + Math.random().toString(36).substring(2);
            }

                        function createOperationEntry(state) {
                const card = document.createElement('div');
                card.className = 'rounded-lg border border-emerald-500/40 bg-emerald-500/10 p-4 text-sm text-emerald-200';
                card.setAttribute('data-operation-card', 'true');

                const header = document.createElement('div');
                header.className = 'flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between';
                card.append(header);

                const title = document.createElement('div');
                title.className = 'flex-1 text-sm';
                header.append(title);

                const strong = document.createElement('span');
                strong.className = 'font-semibold';
                strong.textContent = 'Repository queued:';
                title.append(strong);
                title.append(' ');

                const messageSpan = document.createElement('span');
                messageSpan.setAttribute('data-notification', 'true');
                title.append(messageSpan);

                const badge = document.createElement('span');
                badge.setAttribute('data-status-badge', 'true');
                header.append(badge);

                const actionContainer = document.createElement('div');
                actionContainer.className = 'flex items-center gap-2';
                header.append(actionContainer);

                const cancelButton = document.createElement('button');
                cancelButton.type = 'button';
                cancelButton.setAttribute('data-cancel', 'true');
                cancelButton.className = 'hidden inline-flex items-center gap-1 rounded-md border border-red-500/40 bg-red-500/10 px-2 py-1 text-xs font-semibold text-red-200 transition hover:bg-red-500/20 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-red-400';
                cancelButton.textContent = 'Stop clone';
                actionContainer.append(cancelButton);

                const closeButton = document.createElement('button');
                closeButton.type = 'button';
                closeButton.setAttribute('data-close', 'true');
                closeButton.className = 'hidden rounded-md border border-white/10 bg-white/5 p-1 text-gray-200 transition hover:bg-white/10 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-500';
                closeButton.innerHTML = '<span class="sr-only">Dismiss notification</span><svg viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="size-4"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 0 1 1.414 0L10 8.586l4.293-4.293a1 1 0 1 1 1.414 1.414L11.414 10l4.293 4.293a1 1 0 0 1-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L8.586 10 4.293 5.707a1 1 0 0 1 0-1.414Z" clip-rule="evenodd"></path></svg>';
                actionContainer.append(closeButton);

                const progressContainer = document.createElement('div');
                progressContainer.className = 'mt-4 space-y-3';
                progressContainer.setAttribute('data-progress-container', 'true');
                card.append(progressContainer);

                const stageLabel = document.createElement('p');
                stageLabel.setAttribute('data-stage-label', 'true');
                stageLabel.className = 'text-sm font-medium text-white';
                progressContainer.append(stageLabel);

                const progressBackground = document.createElement('div');
                progressBackground.className = 'overflow-hidden rounded-full bg-white/10';
                progressContainer.append(progressBackground);

                const progressBar = document.createElement('div');
                progressBar.className = 'h-2 rounded-full bg-indigo-500 transition-all duration-500 ease-out';
                progressBar.setAttribute('data-progress-bar', 'true');
                progressBar.style.width = '1%';
                progressBackground.append(progressBar);

                const progressMeta = document.createElement('div');
                progressMeta.className = 'flex items-center justify-between text-xs font-medium text-gray-400';
                progressContainer.append(progressMeta);

                const progressLabel = document.createElement('span');
                progressLabel.textContent = 'Progress';
                progressMeta.append(progressLabel);

                const progressValue = document.createElement('span');
                progressValue.setAttribute('data-progress-value', 'true');
                progressValue.textContent = '0%';
                progressMeta.append(progressValue);

                const stageGrid = document.createElement('div');
                stageGrid.className = 'mt-3 grid grid-cols-4 text-xs font-medium text-gray-400';
                stageGrid.setAttribute('data-progress-steps', 'true');
                progressContainer.append(stageGrid);

                stageGrid.innerHTML = '' +
                    '<div class="text-indigo-400" data-step="queued">Queued</div>' +
                    '<div class="text-center text-gray-400" data-step="receiving">Downloading</div>' +
                    '<div class="text-center text-gray-400" data-step="resolving">Verifying</div>' +
                    '<div class="text-right text-gray-400" data-step="completed">Ready</div>';

                const messageParagraph = document.createElement('p');
                messageParagraph.className = 'mt-3 text-xs text-gray-400';
                messageParagraph.setAttribute('data-progress-message', 'true');
                progressContainer.append(messageParagraph);

                const summaryContainer = document.createElement('div');
                summaryContainer.className = 'mt-4 rounded-md border border-white/10 bg-black/30 px-3 py-2 text-xs text-gray-200';
                summaryContainer.setAttribute('data-summary', 'true');
                summaryContainer.style.display = 'none';
                card.append(summaryContainer);

                return {
                    card: card,
                    badge: badge,
                    titleLabel: strong,
                    messageSpan: messageSpan,
                    progressContainer: progressContainer,
                    stageLabel: stageLabel,
                    progressBar: progressBar,
                    progressValue: progressValue,
                    messageParagraph: messageParagraph,
                    stepsContainer: stageGrid,
                    summaryContainer: summaryContainer,
                    pollTimerId: null,
                    cancelButton: cancelButton,
                    closeButton: closeButton,
                    isActive: state.isActive,
                    state: state.state,
                    operationId: state.operationId,
                    repositoryUrl: state.repositoryUrl
                };
            }
function updateOperationEntry(entry, state) {
                const wasActive = entry.isActive === true;
                const normalizedStage = state.stage && state.stage.length > 0 ? state.stage : 'Processing repository...';
                const normalizedMessage = state.message && state.message.length > 0 ? state.message : defaultMessageForState(state.state);
                const boundedPercentage = clampPercentage(state.percentage);
                const displayPercentage = boundedPercentage.toFixed(1) + '%';
                const info = computeBadgeInfo(state.state, state.isActive);

                entry.card.className = cardClassForState(state.state);
                entry.titleLabel.textContent = headingForState(state.state, state.isActive);
                entry.messageSpan.textContent = state.notification || state.repositoryUrl || 'Repository clone';
                entry.badge.textContent = info.badgeText;
                entry.badge.className = info.badgeClass;
                entry.operationId = state.operationId;
                entry.repositoryUrl = state.repositoryUrl;

                if (state.isActive) {
                    entry.progressContainer.style.display = '';
                    entry.summaryContainer.style.display = 'none';
                    if (entry.closeButton) {
                        entry.closeButton.classList.add('hidden');
                    }
                    entry.stageLabel.textContent = normalizedStage;
                    entry.progressBar.style.width = Math.max(1, Math.min(boundedPercentage, 100)).toFixed(1) + '%';
                    entry.progressBar.classList.remove('bg-indigo-500', 'bg-emerald-500', 'bg-red-500');
                    entry.progressBar.classList.add(info.progressClass);
                    entry.progressValue.textContent = displayPercentage;
                    entry.messageParagraph.textContent = normalizedMessage;
                    updateSteps(entry.stepsContainer, normalizedStage, state.state);
                    if (entry.cancelButton) {
                        entry.cancelButton.classList.remove('hidden');
                        if (entry.cancelButton.dataset.pending === 'true') {
                            setCancelButtonDisabled(entry.cancelButton, true, true);
                        } else {
                            setCancelButtonDisabled(entry.cancelButton, false, false);
                        }
                    }
                } else {
                    entry.progressContainer.style.display = 'none';
                    entry.summaryContainer.style.display = '';
                    entry.summaryContainer.textContent = finalMessageForState(state.state, state.message);
                    if (entry.closeButton) {
                        entry.closeButton.classList.remove('hidden');
                    }
                    if (state.state === 'Completed') {
                        scheduleRepositoryRefresh();
                    }
                    if (entry.cancelButton) {
                        entry.cancelButton.classList.add('hidden');
                        setCancelButtonDisabled(entry.cancelButton, true, false);
                    }
                }

                entry.isActive = state.isActive;
                entry.state = state.state;

                if (wasActive && !entry.isActive) {
                    scheduleRepositoryRefresh();
                }
            }

            function defaultMessageForState(stateName) {
                const normalized = (stateName || '').toLowerCase();

                if (normalized === 'failed') {
                    return 'Repository clone failed. Please verify the URL or credentials.';
                }

                if (normalized === 'completed') {
                    return 'Clone completed successfully. Preparing the repository list...';
                }

                if (normalized === 'canceled') {
                    return 'Repository clone was canceled. Partial data was removed.';
                }

                return 'We are cloning your repository. This usually takes less than a minute.';
            }

            function headingForState(stateName, isActive) {
                const normalized = (stateName || '').toLowerCase();

                if (normalized === 'failed') {
                    return 'Repository clone failed:';
                }

                if (normalized === 'completed') {
                    return 'Repository cloned:';
                }

                if (normalized === 'canceled') {
                    return 'Repository clone canceled:';
                }

                if (normalized === 'running' && isActive) {
                    return 'Repository cloning:';
                }

                return 'Repository queued:';
            }

            function cardClassForState(stateName) {
                const normalized = (stateName || '').toLowerCase();

                if (normalized === 'failed') {
                    return 'rounded-lg border border-red-500/40 bg-red-500/10 p-4 text-sm text-red-100';
                }

                if (normalized === 'completed') {
                    return 'rounded-lg border border-emerald-500/40 bg-emerald-500/10 p-4 text-sm text-emerald-200';
                }

                if (normalized === 'canceled') {
                    return 'rounded-lg border border-amber-500/40 bg-amber-500/10 p-4 text-sm text-amber-200';
                }

                return 'rounded-lg border border-indigo-500/40 bg-indigo-500/10 p-4 text-sm text-indigo-100';
            }

            function finalMessageForState(stateName, message) {
                if (message && message.length > 0) {
                    return message;
                }

                const normalized = (stateName || '').toLowerCase();

                if (normalized === 'completed') {
                    return 'Clone completed successfully.';
                }

                if (normalized === 'failed') {
                    return 'Clone failed. Please review the repository URL or credentials.';
                }

                if (normalized === 'canceled') {
                    return 'Clone canceled. Partial files were cleaned up.';
                }

                return 'Clone status updated.';
            }

            function schedulePoll(entry, operationId) {
                stopPolling(entry);

                entry.pollTimerId = window.setTimeout(function () {
                    pollOperation(entry, operationId);
                }, 1500);
            }

            function stopPolling(entry) {
                if (entry.pollTimerId !== null) {
                    window.clearTimeout(entry.pollTimerId);
                    entry.pollTimerId = null;
                }
            }

            function pollOperation(entry, operationId) {
                fetch('/api/repositories/clone/' + operationId, { cache: 'no-store', credentials: 'same-origin' })
                    .then(function (response) {
                        if (!response.ok) {
                            throw new Error('Status response not available.');
                        }

                        return response.json();
                    })
                    .then(function (payload) {
                        if (!payload) {
                            return;
                        }

                        const viewState = convertStatusToViewState(payload);
                        upsertOperation(viewState);
                    })
                    .catch(function () {
                        // retry with back-off
                        schedulePoll(entry, operationId);
                    });
            }

            function showError(message) {
                if (cloneError) {
                    cloneError.textContent = message || '';
                }
            }

            function setFormDisabled(disabled) {
                if (!cloneSubmit) {
                    return;
                }

                if (disabled) {
                    cloneSubmit.setAttribute('disabled', 'disabled');
                    cloneSubmit.classList.add('opacity-70');
                } else {
                    cloneSubmit.removeAttribute('disabled');
                    cloneSubmit.classList.remove('opacity-70');
                }
            }

            function updateSteps(container, stageText, stateName) {
                if (!container) {
                    return;
                }

                const normalizedStage = (stageText || '').toLowerCase();
                const normalizedState = (stateName || '').toLowerCase();
                const stepElements = container.querySelectorAll('[data-step]');

                stepElements.forEach(function (element) {
                    const step = element.getAttribute('data-step');

                    if (!step) {
                        return;
                    }

                    let active = false;

                    switch (step) {
                        case 'queued':
                            active = true;
                            break;
                        case 'receiving':
                            active = normalizedStage.includes('receiving') || normalizedStage.includes('transfer');
                            break;
                        case 'resolving':
                            active = normalizedStage.includes('resolving') || normalizedStage.includes('index');
                            break;
                        case 'completed':
                            active = normalizedStage.includes('complete') || normalizedStage.includes('ready') || normalizedState === 'completed';
                            break;
                        default:
                            active = false;
                            break;
                    }

                    element.classList.remove('text-indigo-400', 'text-emerald-400');

                    if (active) {
                        element.classList.remove('text-gray-400');

                        if (step === 'completed' && normalizedState === 'completed') {
                            element.classList.add('text-emerald-400');
                        } else {
                            element.classList.add('text-indigo-400');
                        }
                    } else {
                        element.classList.add('text-gray-400');
                    }
                });
            }

            function convertApiResponseToState(response) {
                const status = response.status || null;
                const operationId = status && status.operationId ? status.operationId : response.operationId || '';
                const percentage = status && typeof status.percentage === 'number'
                    ? status.percentage
                    : (status && status.percentage ? parseFloat(status.percentage) : 0);
                const stage = status && status.stage ? status.stage : '';
                const message = status && status.message ? status.message : '';
                const stateName = status && status.state ? status.state : (response.alreadyCloned ? 'Completed' : 'Queued');
                const notification = response.notification || response.repositoryUrl || 'Repository clone';

                const normalizedState = (stateName || '').toLowerCase();

                return {
                    operationId: operationId,
                    repositoryUrl: response.repositoryUrl || '',
                    notification: notification,
                    percentage: percentage,
                    stage: stage,
                    message: message,
                    state: stateName,
                    isActive: normalizedState === 'queued' || normalizedState === 'running'
                };
            }

            function convertStatusToViewState(status) {
                const stateName = status.state || 'Queued';
                const normalizedState = (stateName || '').toLowerCase();

                return {
                    operationId: status.operationId || '',
                    repositoryUrl: status.repositoryUrl || '',
                    notification: status.repositoryUrl || 'Repository clone',
                    percentage: typeof status.percentage === 'number' ? status.percentage : parseFloat(status.percentage || '0') || 0,
                    stage: status.stage || '',
                    message: status.message || '',
                    state: stateName,
                    isActive: normalizedState === 'queued' || normalizedState === 'running'
                };
            }

            function refreshRepositories() {
                if (!repositoryList) {
                    return;
                }

                fetch('/Home/RepositoryList', {
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    credentials: 'same-origin'
                })
                    .then(function (response) {
                        if (!response.ok) {
                            throw new Error('Unable to refresh repository list.');
                        }

                        return response.text();
                    })
                    .then(function (html) {
                        const parser = new DOMParser();
                        const documentFragment = parser.parseFromString(html, 'text/html');
                        const payload = documentFragment.querySelector('[data-repository-payload]');

                        if (!payload) {
                            return;
                        }

                        repositoryList.innerHTML = payload.innerHTML;
                        bindRepositoryActions();

                        const countAttribute = payload.getAttribute('data-count');
                        const repositoryCount = parseInt(countAttribute || '0', 10) || 0;

                        if (repositoryCountLabel) {
                            repositoryCountLabel.textContent = formatRepositoryCount(repositoryCount);
                            repositoryCountLabel.dataset.count = repositoryCount.toString();
                        }
                    })
                    .catch(function (error) {
                        console.warn(error);
                    });
            }

            function bindRepositoryActions() {
                if (!repositoryList) {
                    return;
                }

                const deleteButtons = repositoryList.querySelectorAll('[data-repository-delete="true"]');

                deleteButtons.forEach(function (button) {
                    if (button.dataset.bound === 'true') {
                        return;
                    }

                    button.dataset.bound = 'true';
                    button.addEventListener('click', function () {
                        handleRepositoryDelete(button);
                    });
                });
            }

            function handleRepositoryDelete(button) {
                if (!button) {
                    return;
                }

                const repositoryName = button.getAttribute('data-repository-name') || '';

                if (!repositoryName) {
                    return;
                }

                const hasRemote = button.getAttribute('data-has-remote') === 'true';
                const hasUncommitted = button.getAttribute('data-has-uncommitted') === 'true';
                const hasUnpushed = button.getAttribute('data-has-unpushed') === 'true';

                const warningLines = [];
                warningLines.push('Are you sure you want to delete the local copy of "' + repositoryName + '"?');
                warningLines.push('The cloned files will be removed immediately.');

                if (!hasRemote) {
                    warningLines.push('No remote origin was detected for this repository.');
                }

                if (hasUncommitted || hasUnpushed) {
                    warningLines.push('Local changes were found that may not exist in the cloud and cannot be recovered.');
                }

                const confirmationMessage = warningLines.join('\n\n');

                if (!window.confirm(confirmationMessage)) {
                    return;
                }

                showRepositoryFeedback('', false);
                setRepositoryDeleteDisabled(button, true);

                const encodedName = encodeURIComponent(repositoryName);

                fetch('/api/repositories/' + encodedName, {
                    method: 'DELETE',
                    credentials: 'same-origin'
                })
                    .then(function (response) {
                        if (!response.ok) {
                            return response.json().then(function (data) {
                                const message = data && data.message ? data.message : 'Failed to delete repository.';
                                throw new Error(message);
                            }).catch(function (error) {
                                throw new Error(error.message || 'Failed to delete repository.');
                            });
                        }

                        return response.json();
                    })
                    .then(function (payload) {
                        const feedbackMessage = payload && payload.message ? payload.message : 'Repository deleted.';
                        showRepositoryFeedback(feedbackMessage, false);
                        refreshRepositories();
                    })
                    .catch(function (error) {
                        showRepositoryFeedback(error.message || 'Failed to delete repository.', true);
                    })
                    .finally(function () {
                        setRepositoryDeleteDisabled(button, false);
                    });
            }

            function setRepositoryDeleteDisabled(button, disabled) {
                if (!button) {
                    return;
                }

                if (disabled) {
                    button.setAttribute('disabled', 'disabled');
                    button.classList.add('opacity-70');
                } else {
                    button.removeAttribute('disabled');
                    button.classList.remove('opacity-70');
                }
            }

            function showRepositoryFeedback(message, isError) {
                if (!repositoryFeedback) {
                    return;
                }

                repositoryFeedback.classList.remove('border-red-500/40', 'text-red-200', 'border-emerald-500/40', 'text-emerald-200');

                if (!message) {
                    repositoryFeedback.classList.add('hidden');
                    repositoryFeedback.textContent = '';
                    repositoryFeedback.classList.add('border-white/10', 'text-gray-200');
                    return;
                }

                repositoryFeedback.textContent = message;
                repositoryFeedback.classList.remove('hidden', 'border-white/10', 'text-gray-200');

                if (isError) {
                    repositoryFeedback.classList.add('border-red-500/40', 'text-red-200');
                } else {
                    repositoryFeedback.classList.add('border-emerald-500/40', 'text-emerald-200');
                }
            }

            function bindCancel(entry) {
                if (!entry.cancelButton || entry.cancelButton.dataset.bound === 'true') {
                    return;
                }

                entry.cancelButton.dataset.bound = 'true';
                entry.cancelButton.dataset.pending = 'false';
                entry.cancelButton.addEventListener('click', function () {
                    requestCancellation(entry);
                });
            }

            function requestCancellation(entry) {
                if (!entry || !entry.cancelButton) {
                    return;
                }

                const operationId = entry.operationId || '';

                if (!operationId || operationId === '00000000-0000-0000-0000-000000000000') {
                    return;
                }

                const repositoryName = entry.repositoryUrl && entry.repositoryUrl.length > 0
                    ? entry.repositoryUrl
                    : (entry.messageSpan && entry.messageSpan.textContent ? entry.messageSpan.textContent : 'this repository');

                const confirmationMessage = 'Stopping the clone for "' + repositoryName + '" will delete any files that have been downloaded so far.\n\nDo you want to continue?';

                if (!window.confirm(confirmationMessage)) {
                    return;
                }

                setCancelButtonDisabled(entry.cancelButton, true, true);

                fetch('/api/repositories/clone/' + operationId, {
                    method: 'DELETE',
                    credentials: 'same-origin'
                })
                    .then(function (response) {
                        if (!response.ok) {
                            return response.json().then(function (data) {
                                const message = data && data.message ? data.message : 'Unable to cancel repository clone.';
                                throw new Error(message);
                            }).catch(function (error) {
                                throw new Error(error.message || 'Unable to cancel repository clone.');
                            });
                        }

                        return response.json();
                    })
                    .then(function (payload) {
                        if (payload && payload.status) {
                            const viewState = convertStatusToViewState(payload.status);
                            upsertOperation(viewState);
                        }
                    })
                    .catch(function (error) {
                        showError(error.message || 'Unable to cancel repository clone.');
                        setCancelButtonDisabled(entry.cancelButton, false, false);
                    });
            }

            function setCancelButtonDisabled(button, disabled, pending) {
                if (!button) {
                    return;
                }

                if (disabled) {
                    button.setAttribute('disabled', 'disabled');
                    button.classList.add('opacity-70');
                } else {
                    button.removeAttribute('disabled');
                    button.classList.remove('opacity-70');
                }

                if (typeof pending === 'boolean') {
                    button.dataset.pending = pending ? 'true' : 'false';
                }
            }

            function bindClose(entry) {
                if (!entry.closeButton || entry.closeButton.dataset.bound === 'true') {
                    return;
                }

                entry.closeButton.dataset.bound = 'true';
                entry.closeButton.addEventListener('click', function () {
                    removeOperationEntry(entry);
                });
            }

            function removeOperationEntry(entry) {
                if (!entry) {
                    return;
                }

                if (entry.card && entry.card.parentElement) {
                    entry.card.parentElement.removeChild(entry.card);
                }

                if (entry.key && operations.has(entry.key)) {
                    operations.delete(entry.key);
                }

                scheduleRepositoryRefresh();
            }

            function formatRepositoryCount(count) {
                return count + ' repository' + (count === 1 ? '' : 'ies') + ' available';
            }

            function scheduleRepositoryRefresh() {
                if (reloadTimerId !== null) {
                    return;
                }

                reloadTimerId = window.setTimeout(function () {
                    refreshRepositories();
                    reloadTimerId = null;
                }, 600);
            }

            function computeBadgeInfo(stateName, isActive) {
                const normalized = (stateName || '').toLowerCase();
                let badgeText = 'In progress';
                let badgeClass = 'inline-flex items-center gap-2 rounded-full border border-indigo-500/40 bg-indigo-500/20 px-2 py-1 text-xs font-semibold text-indigo-200';
                let progressClass = 'bg-indigo-500';

                if (normalized === 'completed') {
                    badgeText = isActive ? 'Completed' : 'Ready';
                    badgeClass = 'inline-flex items-center gap-2 rounded-full border border-emerald-500/50 bg-emerald-500/20 px-2 py-1 text-xs font-semibold text-emerald-200';
                    progressClass = 'bg-emerald-500';
                } else if (normalized === 'failed') {
                    badgeText = 'Failed';
                    badgeClass = 'inline-flex items-center gap-2 rounded-full border border-red-500/50 bg-red-500/20 px-2 py-1 text-xs font-semibold text-red-200';
                    progressClass = 'bg-red-500';
                } else if (normalized === 'canceled') {
                    badgeText = 'Canceled';
                    badgeClass = 'inline-flex items-center gap-2 rounded-full border border-amber-500/40 bg-amber-500/20 px-2 py-1 text-xs font-semibold text-amber-200';
                    progressClass = 'bg-amber-500';
                } else if (normalized === 'queued') {
                    badgeText = 'Queued';
                }

                return {
                    badgeText: badgeText,
                    badgeClass: badgeClass,
                    progressClass: progressClass
                };
            }

            function clampPercentage(value) {
                if (!Number.isFinite(value)) {
                    return 0;
                }

                if (value < 0) {
                    return 0;
                }

                if (value > 100) {
                    return 100;
                }

                return value;
            }
        });
    </script>
    <partial name="_ValidationScriptsPartial" />
}
